// STATE.js

const localdb = require('../../../../src/node_modules/localdb')
const db = localdb()
const status = {
  root_module: true, 
  root_instance: true, 
  overrides: {},
  tree: {},
  tree_pointers: {},
  modulepaths: [],
  orphans: {},
  db
}
//@TODO Where devs can define slots
const default_slots = ['_', 'inputs']

const version = 9
if(db.read(['playproject_version']) != version){
  localStorage.clear()
  status.fallback_check = true
  db.add(['playproject_version'], version)
}
// db.read(['state']) || db.add(['state'], {})

const listeners = {}
const s2i = {}
const i2s = {}
var admins = [0]

module.exports = STATE
function STATE (address, modulepath) {
  status.modulepaths.push(modulepath)
  const local_status = {
    name: extract_filename(address),
    deny: {}, subs: []
  }

  const sdb = { watch, get_sub, req_access }
  const subs = [get]
  const admin = { xget, get_all, add_admins, load }
  return statedb

  function extract_filename (address) {
    const parts = address.split('/node_modules/')
    const last = parts.at(-1).split('/')
    return last.at(-1).slice(0, -3)
  }
  function statedb (fallback_module, fallback_instance) {
    local_status.fallback_instance = fallback_instance
    const search_filters = {'path': modulepath }
    let data = db.find(['state'], search_filters)
    if (status.fallback_check) {
      if(!data){
        if(status.root_module){
          status.root_module = false
          preprocess(fallback_module, 'module', {id: 0})
        }
        else{
          find_super('module', fallback_module)
        }
      }
      else
        preprocess(fallback_module, 'module', data)
      data = db.find(['state'], search_filters)
    }
    if(data.id == 0){
      data.admins && add_admins(data.admins)
    }

    local_status.id = data.id
    local_status.module_id = data.id
    data.hubs && add_source(data.hubs)
    const sub_modules = {}
    data.subs && data.subs.forEach(id => {
      const temp = db.read(['state', id]).type
      console.log('ok',sub_modules, temp)
      sub_modules[temp] = id
    })
    return { id: data.id, sdb, subs, sub_modules }
  }
  function find_super (xtype, fallback) {
    const split = modulepath.split('/')
    const name = split.at(-2) + '.' + split.at(-1)
    const modulepath_parent = modulepath.split(/\/(?=[^\/]*$)/)[0]
    const search_filters = {'path': modulepath_parent }
    let data = db.find(['state'], search_filters) || db.find(['state'], {path: modulepath})
    console.log(data)
    if(xtype === 'instance')
      data = db.find(['state'], {'type': data.id})
    data.idx = name
    data.name = split.at(-1)
    console.log(JSON.parse(JSON.stringify(data)), modulepath_parent)
    return preprocess(fallback, xtype, data, {name, module_id: data.type}, true)
  }
  function add_source (hubs) {
    hubs.forEach(id => {
      const data = db.read(['state', id])
      if(data.type === 'js'){
        fetch_save(data)
      }
    })
  }
  function symbolfy (data) {
    data.subs && data.subs.forEach(sub => {
      const substate = db.read(['state', sub])
      s2i[i2s[sub] = Symbol(sub)] = sub
      local_status.subs.push({ sid: i2s[sub], type: substate.type })
      if(substate.orphan){
        const substate_module = db.read(['state', substate.type])
        if(status.orphans[substate_module.path])
          status.orphans[substate_module.path].push(sub)
        else
          status.orphans[substate_module.path] = [sub]
      }
    })
  }
  function load (snapshot) {
    localStorage.clear()
    Object.entries(snapshot).forEach(([key, value]) => {
      db.add([key], JSON.parse(value), true)
    })
    window.location.reload()
  }
  function get (sid) {
    let id = s2i[sid]
    let data = db.read(['state', id])
    if(status.fallback_check){
      if(!data && !status.root_instance){
        id = find_super('instance', local_status.fallback_instance)
      }
      else
        id = preprocess(local_status.fallback_instance, 'instance', data)
      data = db.read(['state', id])
    }
    if(status.root_instance){
      status.tree = JSON.parse(JSON.stringify(status.tree))
      data = db.find(['state'], { type: local_status.module_id})
      status.root_instance = false
    }
    if(!data){
      id = status.orphans[modulepath].pop()
      data = db.read(['state', id])
    }
    local_status.id = data.id
    symbolfy(data)
    window.STATEMODULE = status
    return {id, sdb}
  }
  function get_path (local_id) {
    const modulepath_parent = modulepath.split(/\/(?=[^\/]*$)/)
    if(modulepath_parent[1])
      return modulepath_parent[0] + '/' + local_id
    else
      return local_id
  }
  async function watch (listener) {
    const data = db.read(['state', local_status.id])
    listeners[data.id] = listener
    const input_map = []
    data.inputs && await Promise.all(data.inputs.map(async input => {
      const input_state = db.read(['state', input])
      const input_data = await fetch_save(input_state)
      input_map.push({ type: input_state.type, data: [input_data] })
    }))
    listener(input_map)
    return local_status.subs
  }
  async function fetch_save({ id, name, $ref, type, data }) {
    const xtype = (typeof(id) === "number" ? name : id).split('.').at(-1)
    let result = db.read([ type, id ])
    if(!result){
      result = data || await((await fetch($ref))[xtype === 'json' ?'json' :'text']())
      db.add([type, id], result)
    }
    return result
  }
  function get_sub (type) {
    return local_status.subs.filter(sub => {
      const dad = db.read(['state', sub.type])
      return dad.type === type
    })
  }
  async function add_admins (ids) {
    admins.push(...ids)
  }
  function req_access (sid) {
    if (local_status.deny[sid]) throw new Error('access denied')
    const el = db.read(['state', s2i[sid]])
    if(admins.includes(s2i[sid]) || admins.includes(el?.name))
      return admin
  }
  function xget (id) {
    return db.read(['state', id])
  }
  function get_all () {
    return db.read_all(['state'])
  }
  function preprocess (fallback, xtype, pre_data = {}, fun_status = local_status, orphan ) {
    let count = db.length(['state'])
    let {id: pre_id, hubs, subs} = pre_data
    let subs_data = {}, subs_types, id_map = {}
    if(subs){
      subs.forEach(id => subs_data[id] = db.read(['state', id]))
      subs_types = new Set(Object.values(subs_data).map(sub => sub.type))
    }
    let host_data
    const instance_path = get_path(pre_data.name)
    console.log(instance_path)
    if (status.overrides[instance_path]) {
      host_data = status.overrides[instance_path]([fallback])
    }
    else
      host_data = fallback()
    reduce_tree(host_data)
    console.log(status.overrides)
    host_data.orphan = orphan
    const on = {
      _: clean_node,
      inputs: clean_file,
    }
    return clean_node('', host_data, modulepath)

    function clean_node (local_id, entry, path, hub_entry, hub_module, local_tree) {
      let module
      const split = local_id.split(':')
      if(local_id){
        entry.hubs = [hub_entry.id]
        if(xtype === 'instance')
          hub_module?.subs && hub_module.subs.forEach(id => {
            const module_data = db.read(['state', id])
            if(module_data.idx.split('.')[0] == split[0].split('$')[0]){
              entry.type = module_data.id
              module = module_data
              return
            }
          })
        else{
          entry.idx = local_id
          const module_split = local_id.split('#')
          entry.type = module_split[0]
          status.tree_pointers[count] = local_tree
          path = path ? path + '/' : path
          let new_path = path + local_id
          if(new_path in status.modulepaths)
            new_path = path + module_split[0] + (Number(module_split[1]) + 1)
          entry.path = new_path
          path = new_path
        }
      }
      else{
        if(xtype === 'instance'){
          module = db.read(['state', fun_status.module_id])
          entry.type = module.id
        }
        else{
          local_tree = JSON.parse(JSON.stringify(entry))
          if(pre_id){
            // console.log(pre_id, pre_data.idx, xtype, local_tree)
            status.tree_pointers[pre_id]._[pre_data.idx] = local_tree
          }
          else{
            status.tree[local_id] = local_tree
          }
          const file_id = fun_status.name+'.js'
          entry.inputs || (entry.inputs = {})
          entry.inputs[file_id] = { $ref: new URL(address, location).href }
          entry.type = entry.type || fun_status.name
          entry.idx = pre_data.idx
          entry.path = path
        }
        hubs && (entry.hubs = hubs)
      }
      entry.id = local_id ? count++ : pre_id || count++
      entry.name = split[0] || entry.name || module?.type || entry.type || fun_status.name
      id_map[local_id] = entry.type
      // console.log(JSON.parse(JSON.stringify(entry)))
      !local_id && default_slots.forEach(slot => {
        if(entry[slot] && on[slot])
          entry[slot === '_' ? 'subs' : slot] = Object.entries(entry[slot])
          .map(([key, value]) => on[slot](key, value, path, entry, module, local_tree))
      })
      delete(entry._)
      db.add(['state', entry.id], entry)
      console.log('Important:', fun_status.name, xtype, local_id, JSON.parse(JSON.stringify(entry)))

      return entry.id
    }
    function clean_file (file_id, entry, hub_entry){
      if(!isNaN(Number(file_id)))
        return file_id
      const file = entry
      file.id = file_id
      file.name = file.name || file_id
      file.type = file.type || file.id.split('.').at(-1)
      file[file.type === 'js' ? 'subs' : 'hubs' ] = [hub_entry.id]
      const copies = Object.keys(db.read_all(['state', file_id]))
      if(copies.length){
        const id = copies.sort().at(-1).split(':')[1]
        file.id = file_id + ':' + (Number(id || 0) + 1)
      }
      db.add(['state', file.id], file)
      return file.id
    }
  }
  function reduce_tree (tree, path = modulepath) {
    let check_override = true, check_sub = false
    check_override = Boolean(tree[0])
    console.log('Tree: ', JSON.parse(JSON.stringify(tree)))
    if(check_override){
      if(!status.overrides[path])
        status.overrides[path] = tree[0]
    }
    path = path ? path + '/' : path
    if(tree._){
      Object.entries(tree._).forEach(([type, data]) => {
        const check = reduce_tree(data, path + type.replace('.', '/'))
        if(!check)
          check_sub = true
      })
    }
    if(!(check_override || check_sub))
      return true
  }
  function merge_trees (fallback, fun_status) {
    return () => {
      const data = fallback()
      traverse (data, fun_status.name)
      function traverse (data, type) {
        if(data._)
          Object.entries(data._).forEach(([type, data]) => traverse(data, type))
        else{
          type = type.split('$')[0]
          const id = db.find(['state'], {type}).id
          data._ = status.tree_pointers[id]?._?.[type]?._
          // console.log(data, id, type, status.tree_pointers[id])
        }
      }
      return data
    }
  }
}