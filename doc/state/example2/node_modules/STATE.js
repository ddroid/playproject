const localdb = require('../../../../src/node_modules/localdb')
const db = localdb()

// Constants and initial setup (global level)
const VERSION = 9

const status = {
  root_module: true, 
  root_instance: true, 
  overrides: {},
  tree: {},
  tree_pointers: {},
  modulepaths: [],
  orphans: {},
  db
}

// Version check and initialization
check_version()

// Symbol mappings
const listeners = {}
const s2i = {}
const i2s = {}
let admins = [0]

// Inner Function
function STATE (address, modulepath) {
  status.modulepaths.push(modulepath)
  
  //Setup local data (module level)
  const local_status = {
    name: extract_filename(address),
    deny: {},
    subs: []
  }
  return statedb
  
  function statedb (fallback_module) {
    const data = get_module_data(fallback_module)
    
    //Setup local data (module level)
    data.id == 0 && data.admins && admins.push(...data.admins)
    local_status.id = data.id
    local_status.module_id = data.id
    data.hubs && add_source(data.hubs)
    
    const sub_modules = {}
    data.subs && data.subs.forEach(id => {
      sub_modules[db.read(['state', id]).type] = id
    })
    
    return {
      id: data.id,
      sdb: create_statedb_interface(local_status, modulepath),
      subs: [get],
      sub_modules
    }
  }
  function find_super (xtype, fallback) {
    const split = modulepath.split('/')
    const name = split.at(-2) + '.' + split.at(-1)
    const modulepath_parent = modulepath.split(/\/(?=[^\/]*$)/)[0]
    const search_filters = {'path': modulepath_parent}
    
    let data = db.find(['state'], search_filters) || db.find(['state'], {path: modulepath})
    
    if (xtype === 'instance') {
      data = db.find(['state'], {'type': data.id})
    }
    
    data.idx = name
    data.name = split.at(-1)
    
    return preprocess(fallback, xtype, data, {name, module_id: data.type}, true)
  }
  function get (sid) {
    const data = get_instance_data(sid)
    
    local_status.id = data.id
    symbolfy(data, local_status)
    window.STATEMODULE = status
    
    return {
      id: data.id,
      sdb: create_statedb_interface(local_status, modulepath)
    }
  }
  function preprocess (fallback, xtype, pre_data = {}, fun_status = local_status, orphan) {
    console.log('Important:', fun_status.name, xtype)
    let count = db.length(['state'])
    let {id: pre_id, hubs} = pre_data
    let id_map = {}
    
    const path = xtype === 'instance' ? get_path(pre_data.name, modulepath) : modulepath

    const host_data = status.overrides[path] ? 
      status.overrides[path]([fallback]) :
      fallback()
    
    if(status.overrides[path])
      delete status.overrides[path]
    if(xtype === 'module')
      local_status.fallback_instance = host_data.api

    register_overrides(host_data, modulepath)
    console.log('overrides: ', status.overrides)
    host_data.orphan = orphan
    return clean_node('', host_data, modulepath)

    
    function clean_node (local_id, entry, path, hub_entry, hub_module, local_tree) {
      let module
      const split = local_id.split(':')
      
      extract_data()
      
      entry.id = local_id ? count++ : pre_id || count++
      entry.name = split[0] || entry.name || module?.type || entry.type || fun_status.name
      id_map[local_id] = entry.type
      
      clean_subs()
      
      delete entry._
      db.add(['state', entry.id], entry)
      return entry.id

      function extract_data () {
        if (local_id) {
          entry.hubs = [hub_entry.id]
          if (xtype === 'instance') {
            hub_module?.subs && hub_module.subs.forEach(id => {
              const module_data = db.read(['state', id])
              if (module_data.idx.split('.')[0] == split[0].split('$')[0]) {
                entry.type = module_data.id
                module = module_data
              }
            })
          } 
          else {
            entry.idx = local_id
            const module_split = local_id.split('#')
            entry.type = module_split[0]
            status.tree_pointers[count] = local_tree
            path = path ? path + '/' : path
            let new_path = path + local_id
            if (new_path in status.modulepaths) {
              new_path = path + module_split[0] + (Number(module_split[1]) + 1)
            }
            entry.path = new_path
            path = new_path
          }
        } 
        else {
          if (xtype === 'instance') {
            module = db.read(['state', fun_status.module_id])
            entry.type = module.id
          } else {
            local_tree = JSON.parse(JSON.stringify(entry))
            if (pre_id) {
              status.tree_pointers[pre_id]._[pre_data.idx] = local_tree
            } else {
              status.tree[local_id] = local_tree
            }
            const file_id = fun_status.name + '.js'
            entry.inputs || (entry.inputs = {})
            entry.inputs[file_id] = { $ref: new URL(address, location).href }
            entry.type = entry.type || fun_status.name
            entry.idx = pre_data.idx
            entry.path = path
          }
          hubs && (entry.hubs = hubs)
        }
        
      }
      function clean_subs () {
        if (!local_id) {
          if(entry._){
            entry.subs = Object.entries(entry._).map(([key, value]) => 
              clean_node(key, value, path, entry, module, local_tree)
          )}
          if(entry.drive){
            entry.inputs = Object.entries(entry.drive.inputs).map(([key, value]) => 
              clean_file(key, value, entry)
            )
        }
        }
      }
    }
    
    function clean_file (file_id, entry, hub_entry) {
      if (!isNaN(Number(file_id))) return file_id
      
      const file = entry
      file.id = file_id
      file.name = file.name || file_id
      file.type = file.type || file.id.split('.').at(-1)
      file[file.type === 'js' ? 'subs' : 'hubs'] = [hub_entry.id]
      
      const copies = Object.keys(db.read_all(['state', file_id]))
      if (copies.length) {
        const id = copies.sort().at(-1).split(':')[1]
        file.id = file_id + ':' + (Number(id || 0) + 1)
      }
      
      db.add(['state', file.id], file)
      return file.id
    }
  }
  function get_module_data (fallback) {
    const search_filters = {'path': modulepath}
    let data = db.find(['state'], search_filters)
    if (status.fallback_check) {
      if (!data) {
        if (status.root_module) {
          status.root_module = false
          preprocess(fallback, 'module', {id: 0})
        } else {
          find_super('module', fallback)
        }
      } else {
        preprocess(fallback, 'module', data)
      }
      data = db.find(['state'], search_filters)
    }
    return data
  }
  function get_instance_data (sid) {
    let id = s2i[sid]
    let data = db.read(['state', id])

    if (status.fallback_check) {
      if (!data && !status.root_instance) {
        id = find_super('instance', local_status.fallback_instance)
      } else {
        id = preprocess(local_status.fallback_instance, 'instance', data)
      }
      data = db.read(['state', id])
    }
    
    if (status.root_instance) {
      status.tree = JSON.parse(JSON.stringify(status.tree))
      data = db.find(['state'], { type: local_status.module_id})
      status.root_instance = false
    }
    
    if (!data) {
      id = status.orphans[modulepath].pop()
      data = db.read(['state', id])
    }
    return data
  }
}

// External Function (helper)
function extract_filename (address) {
  const parts = address.split('/node_modules/')
  const last = parts.at(-1).split('/')
  return last.at(-1).slice(0, -3)
}
function get_path (local_id, modulepath) {
  const modulepath_parent = modulepath.split(/\/(?=[^\/]*$)/)
  return modulepath_parent[1] ? 
    modulepath_parent[0] + '/' + local_id : 
    local_id
}
async function fetch_save ({ id, name, $ref, type, data }) {
  const xtype = (typeof(id) === "number" ? name : id).split('.').at(-1)
  let result = db.read([type, id])
  
  if (!result) {
    result = data || await((await fetch($ref))[xtype === 'json' ? 'json' : 'text']())
    db.add([type, id], result)
  }
  return result
}
function add_source (hubs) {
  hubs.forEach(id => {
    const data = db.read(['state', id])
    if (data.type === 'js') {
      fetch_save(data)
    }
  })
}
function symbolfy (data, local_status) {
  data.subs && data.subs.forEach(sub => {
    const substate = db.read(['state', sub])
    s2i[i2s[sub] = Symbol(sub)] = sub
    local_status.subs.push({ sid: i2s[sub], type: substate.type })
    
    if (substate.orphan) {
      const substate_module = db.read(['state', substate.type])
      if (status.orphans[substate_module.path]) {
        status.orphans[substate_module.path].push(sub)
      } else {
        status.orphans[substate_module.path] = [sub]
      }
    }
  })
}
function register_overrides (tree, path = '') {
  let check_override = true
  let check_sub = false
  
  check_override = Boolean(tree[0])
  if (check_override && !status.overrides[path]) {
    status.overrides[path] = tree[0]
  }
  
  path = path ? path + '/' : path
  
  if (tree._) {
    Object.entries(tree._).forEach(([type, data]) => {
      const check = register_overrides(data, path + type.replace('.', '/'))
      if (!check) check_sub = true
    })
  }
  
  return !(check_override || check_sub)
}
function check_version () {
  if (db.read(['playproject_version']) != VERSION) {
    localStorage.clear()
    status.fallback_check = true
    db.add(['playproject_version'], VERSION)
  }
}

// Public Function
function create_statedb_interface (local_status, modulepath) {
  return {
    watch, get_sub, req_access
  }
  async function watch (listener) {
    const data = db.read(['state', local_status.id])
    listeners[data.id] = listener
    const input_map = []
    
    if (data.inputs) {
      await Promise.all(data.inputs.map(async input => {
        const input_state = db.read(['state', input])
        const input_data = await fetch_save(input_state)
        input_map.push({ type: input_state.type, data: [input_data] })
      }))
    }
    
    listener(input_map)
    return local_status.subs
  }
  function get_sub (type) {
    return local_status.subs.filter(sub => {
      const dad = db.read(['state', sub.type])
      return dad.type === type
    })
  }
  function req_access (sid) {
    if (local_status.deny[sid]) throw new Error('access denied')
    const el = db.read(['state', s2i[sid]])
    if (admins.includes(s2i[sid]) || admins.includes(el?.name)) {
      return {
        xget: (id) => db.read(['state', id]),
        get_all: () => db.read_all(['state']),
        add_admins: (ids) => { admins.push(...ids) },
        load: (snapshot) => {
          localStorage.clear()
          Object.entries(snapshot).forEach(([key, value]) => {
            db.add([key], JSON.parse(value), true)
          })
          window.location.reload()
        }
      }
    }
  }
}


module.exports = STATE