const localdb = require('../../../../src/node_modules/localdb')
const db = localdb()
/** Data stored in a entry in db by STATE:
 * id (String): Node Path 
 * name (String): Any (To be used theme_widget)
 * type (String): Module Name for module / Module id for instances
 * hubs (Array): List of hub-nodes
 * subs (Array): List of sub-nodes
 * inputs (Array): List of input files
 */

// Constants and initial setup (global level)
const VERSION = 9

const status = {
  root_module: true, 
  root_instance: true, 
  overrides: {},
  tree: {},
  tree_pointers: {},
  modulepaths: {},
  db
}

// Version check and initialization
check_version()

// Symbol mappings
const listeners = {}
const s2i = {}
const i2s = {}
let admins = [0]

// Inner Function
function STATE (address, modulepath) {
  status.modulepaths[modulepath] = 0
  
  //Variables (module-level)
  const local_status = {
    name: extract_filename(address),
    module_id: modulepath,
    instance_ids: [],
    deny: {},
    subs: []
  }
  return statedb
  
  function statedb (fallback_module) {
    const data = get_module_data(fallback_module)
    
    //Setup local data (module level)
    if(status.root_module){
      status.root_module = false
      data.admins && admins.push(...data.admins)
    }
    local_status.id = data.id
    local_status.module_id = data.id
    data.hubs && add_source(data.hubs)
    
    const sub_modules = {}
    data.subs && data.subs.forEach(id => {
      sub_modules[db.read(['state', id]).type] = id
    })
    window.STATEMODULE = status

    return {
      id: data.id,
      sdb: create_statedb_interface(local_status, modulepath),
      subs: [get],
      sub_modules
    }
  }
  function find_super ({ xtype, fallback }) {
    const split = modulepath.split('/')
    const name = split.at(-2) + '.' + split.at(-1)
    const modulepath_parent = modulepath.split(/\/(?=[^\/]*$)/)[0]
    
    let data = db.read(['state', modulepath_parent]) || db.read(['state', modulepath])
    
    if (xtype === 'instance') {
      data = db.read(['state', modulepath_parent])
    }
    
    data.name = split.at(-1)
    if(xtype === 'module')
      data.path = data.id = modulepath
    else
      data.path = data.id = get_instance_path(modulepath)
    status.tree_pointers[modulepath] = status.tree_pointers[modulepath_parent] 
    local_status.name = name

    return preprocess({ 
      fallback, xtype, 
      pre_data: data, 
      orphan_check: true })
  }
  function get (sid) {
    const data = get_instance_data(sid)
    
    local_status.id = data.id
    symbolfy(data, local_status)
    window.STATEMODULE = status
    
    return {
      id: data.id,
      sdb: create_statedb_interface(local_status, modulepath)
    }
  }
  function preprocess ({ fallback, xtype, pre_data = {}, orphan_check }) {
    const entries = {}
    let {id: pre_id, hubs: pre_hubs} = pre_data

    validate(fallback())
    
    const fallback_data = status.overrides[pre_id] ? 
      status.overrides[pre_id]([fallback]) :
      fallback()
      
    if(status.overrides[pre_id])
      delete status.overrides[pre_id]
    if(xtype === 'module')
      local_status.fallback_instance = fallback_data.api


    register_overrides(fallback_data, modulepath)
    // console.log('overrides: ', status.overrides)
    orphan_check && (fallback_data.orphan = orphan_check)
    const id = sanitize_state({ local_id: '', entry: fallback_data, path: pre_id })
    return {entries, id}

    
    function sanitize_state ({ local_id, entry, path, hub_entry, local_tree }) {
      [path, entry, local_tree] = extract_data({ local_id, entry, path, hub_entry, local_tree })
      
      entry.id = path
      entry.name = local_id.split(':')[0]
      
      sanitize_subs({ local_id, entry, path, local_tree })
      
      delete entry._
      delete entry.drive
      entries[entry.id] = entry
      // console.log('Entry: ', entry)
      return entry.id
    }
    function extract_data ({ local_id, entry, path, hub_entry, local_tree }) {
      if (local_id) {
        entry.hubs = [hub_entry.id]
        if (xtype === 'instance') {
          let temp_path = path.split(':')[0]
          temp_path = temp_path ? temp_path + '/' : temp_path
          const module_id = temp_path + local_id.split('$')[0]
          entry.type = module_id
          path = module_id + ':' + status.modulepaths[module_id]++

        } 
        else {
          entry.type = local_id
          path = path ? path + '/' : ''
          path = path + local_id
          status.tree_pointers[path] = local_tree
        }
      } 
      else {
        if (xtype === 'instance') {
          entry.type = local_status.module_id
        } else {
          local_tree = JSON.parse(JSON.stringify(entry))
          // console.log('pre_id:', pre_id)
          if (pre_id) {
            status.tree_pointers[pre_id]._[local_status.name] = local_tree
          } else {
            status.tree[local_id] = local_tree
          }
          const file_id = local_status.name + '.js'
          entry.inputs || (entry.inputs = {})
          entry.inputs[file_id] = { $ref: new URL(address, location).href }
          entry.type = local_status.name
        }
        pre_hubs && (entry.hubs = pre_hubs)
      }
      return [path, entry, local_tree]
    }
    function sanitize_subs ({ local_id, entry, path, local_tree }) {
      if (!local_id) {
        if(entry._){
          entry.subs = Object.entries(entry._).map(([local_id, value]) => 
            sanitize_state({ local_id, entry: value, path, hub_entry: entry, local_tree })
        )}
        if(entry.drive){
          entry.inputs = Object.entries(entry.drive.inputs).map(([key, value]) => 
            sanitize_file(key, value, entry)
          )
      }
      }
    }
    function sanitize_file (file_id, entry, hub_entry) {
      if (!isNaN(Number(file_id))) return file_id
      
      const file = entry
      file.id = file_id
      file.name = file.name || file_id
      file.type = file.type || file.id.split('.').at(-1)
      file[file.type === 'js' ? 'subs' : 'hubs'] = [hub_entry.id]
      
      const copies = Object.keys(db.read_all(['state', file_id]))
      if (copies.length) {
        const id = copies.sort().at(-1).split(':')[1]
        file.id = file_id + ':' + (Number(id || 0) + 1)
      }
      entries[file.id] = file
      return file.id
    }
  }
  function get_module_data (fallback) {
    let data = db.read(['state', modulepath])
    data?.orphan && (local_status.orphan = true)

    if (status.fallback_check) {
      let result
      if (data) {
        result = preprocess({fallback, xtype: 'module', pre_data: data })
      } 
      else if (status.root_module) {
        status.root_module = false
        result = preprocess({fallback, xtype: 'module', pre_data: {id: modulepath}})
      } 
      else {
        result = find_super({xtype: 'module', fallback})
      }
      data = result.entries[result.id]
      db.append(['state'], result.entries)
    }
    return data
  }
  function get_instance_data (sid) {
    let id = s2i[sid]
    let data = id && db.read(['state', id])

    if (status.fallback_check) {
      let result
      if (!data && !status.root_instance) {
        result = find_super({ xtype: 'instance', fallback: local_status.fallback_instance})
      } else {
        result = preprocess({
          fallback: local_status.fallback_instance, 
          xtype: 'instance', 
          pre_data: data || {id: get_instance_path(modulepath)}
        })
      }
      data = result.entries[result.id]
      db.append(['state'], result.entries)
    }
    else if (status.root_instance) {
      data = db.read(['state', id || get_instance_path(modulepath)])
      status.tree = JSON.parse(JSON.stringify(status.tree))
      status.root_instance = false
    }
    
    if (!data && local_status.orphan) {
      data = db.read(['state', get_instance_path(modulepath)])
    }
    return data
  }
}

// External Function (helper)
function validate (data) {
  /**  Expected structure and types
   * Sample : "key1|key2:*:type1|type2"
   * ":" : separator
   * "|" : OR
   * "*" : Required key
   * 
   * */
  const errors = []
  const expected_structure = {
    '_': {
      ":*": { // Required key, any name allowed
        "0": () => {}, // Optional key
      },
    },
    'drive': {
      'inputs:*': { // Required key
        ":*": { // Required key, any name allowed
          "data|link:*:object|string": {}, // data or link are names, required, object or string are types
          "link": "string"
        },
      },
    },
  };


  validate_shape(data, expected_structure);
  if (errors.length > 0) 
    console.error("Validation failed:", ...errors);

  function validate_shape (obj, expected, super_node = 'root') {
    const keys = Object.keys(obj)
    const values = Object.values(obj)

    Object.entries(expected).forEach(([expected_key, expected_value]) => {
      let [expected_key_names, required, expected_types] = expected_key.split(':')
      expected_types = expected_types ? expected_types.split('|') : [typeof(expected_value)]
      let absent = true

      if(expected_key_names)
        expected_key_names.split('|').forEach(expected_key_name => {
          const value = obj[expected_key_name]

          if(value){
            const type = typeof(value)
            absent = false

            if(expected_types.includes(type))
              type === 'object' && validate_shape(value, expected_value, expected_key_name)
            else
              errors.push(`Type mismatch: Expected "${expected_types.join(' or ')}" got "${type}" for key "${expected_key_name}" at: `, obj)
          }
        })
      else if(required){
        values.forEach((value, index) => {
          absent = false
          const type = typeof(value)
          
          if(expected_types.includes(type))
            expected_types.includes('object') && validate_shape(value, expected_value, keys[index])
          else
            errors.push(`Type mismatch: Expected "${expected_types.join(' or ')}" got "${type}" for key "${keys[index]}" at: `, obj)
        })
      }

      if(absent && required){
        if(expected_key_names)
          errors.push(`Can't find required key "${expected_key_names.replace('|', ' or ')}" at: `, obj)
        else
          errors.push(`No subs found for super key "${super_node}" at sub:`, obj)
      }
    })
  }
}
function extract_filename (address) {
  const parts = address.split('/node_modules/')
  const last = parts.at(-1).split('/')
  return last.at(-1).slice(0, -3)
}
function get_instance_path (modulepath, modulepaths = status.modulepaths) {
  return modulepath + ':' + modulepaths[modulepath]++
}
async function fetch_save ({ id, name, $ref, type, data }) {
  const xtype = (typeof(id) === "number" ? name : id).split('.').at(-1)
  let result = db.read([type, id])
  
  if (!result) {
    result = data || await((await fetch($ref))[xtype === 'json' ? 'json' : 'text']())
    db.add([type, id], result)
  }
  return result
}
function add_source (hubs) {
  hubs.forEach(id => {
    const data = db.read(['state', id])
    if (data.type === 'js') {
      fetch_save(data)
    }
  })
}
function symbolfy (data, local_status) {
  data.subs && data.subs.forEach(sub => {
    const substate = db.read(['state', sub])
    s2i[i2s[sub] = Symbol(sub)] = sub
    local_status.subs.push({ sid: i2s[sub], type: substate.type })
  })
}
function register_overrides (tree, path = '', xtype = 'instance', local_modulepaths = {}) {
  let check_override = true
  let check_sub = false
  local_modulepaths[path] = 0
  check_override = Boolean(tree[0])
  if (check_override) {
    let resultant_path = path
    if(xtype === 'instance')
      resultant_path = get_instance_path(path.split('$')[0], local_modulepaths)
    if(!status.overrides[resultant_path])
      status.overrides[resultant_path] = tree[0]
  }
  
  path = path ? path + '/' : path
  
  if (tree._) {
    Object.entries(tree._).forEach(([type, data]) => {
      const check = register_overrides(data, path + type.replace('.', '/'), xtype, local_modulepaths)
      if (!check) check_sub = true
    })
  }
  
  return !(check_override || check_sub)
}
function check_version () {
  if (db.read(['playproject_version']) != VERSION) {
    localStorage.clear()
    status.fallback_check = true
    db.add(['playproject_version'], VERSION)
  }
}

// Public Function
function create_statedb_interface (local_status, modulepath) {
  return {
    watch, get_sub, req_access
  }
  async function watch (listener) {
    const data = db.read(['state', local_status.id])
    listeners[data.id] = listener
    const input_map = []
    
    if (data.inputs) {
      await Promise.all(data.inputs.map(async input => {
        const input_state = db.read(['state', input])
        const input_data = await fetch_save(input_state)
        input_map.push({ type: input_state.type, data: [input_data] })
      }))
    }
    
    listener(input_map)
    return local_status.subs
  }
  function get_sub (type) {
    return local_status.subs.filter(sub => {
      const dad = db.read(['state', sub.type])
      return dad.type === type
    })
  }
  function req_access (sid) {
    if (local_status.deny[sid]) throw new Error('access denied')
    const el = db.read(['state', s2i[sid]])
    if (admins.includes(s2i[sid]) || admins.includes(el?.name)) {
      return {
        xget: (id) => db.read(['state', id]),
        get_all: () => db.read_all(['state']),
        add_admins: (ids) => { admins.push(...ids) },
        load: (snapshot) => {
          localStorage.clear()
          Object.entries(snapshot).forEach(([key, value]) => {
            db.add([key], JSON.parse(value), true)
          })
          window.location.reload()
        }
      }
    }
  }
}


module.exports = STATE