const STATE = require('../../../../src/node_modules/STATE')
const statedb = STATE(__filename)
const { sdb, subs: [get] } = statedb(fallback_module)

function fallback_module () {
    return {
    api: fallback_instance,
    _: {
        btn1: {},
        btn2: {},
        btn3: {},
        btn4: {},
        text: {}
    },
    drive: {
        style: {
            'theme.css': {
                    raw: `
                    .menu {
                        display: flex;
                        gap: 10px;
                        margin-bottom: 10px;
                    }
                    .text-container {
                        border: 1px solid #ccc;
                        padding: 10px;
                    }`
                }
            }
        }
    }
}
function fallback_instance () {
    return {}
}
//@ISSUE#2
// 1. fallback_instance should be inside fallback_module function (repeat this for all sub-modules here)
// 2. button instances are defined inside fallback_module instead of fallback_instance
// 3. Drive declared inside module fallback but used for instances

//@ISSUE#3
// Don't use `./` when requiring modules
const btn1 = require('./btn1')
const btn2 = require('./btn2')
const btn3 = require('./btn3')
const btn4 = require('./btn4')
const text_module = require('./text')

module.exports = test_menu
async function test_menu (opts) {
    const { id, sdb } = await get(opts.sid)
    const on = {
    style: inject
    }

    const el = document.createElement('div')
    const shadow = el.attachShadow({ mode: 'closed' })
    shadow.innerHTML = `
    <div class="menu"></div>
    <div class="text-container"></div>
    <style></style>
    `
    const menu_el = shadow.querySelector('.menu')
    const text_container_el = shadow.querySelector('.text-container')
    const style_el = shadow.querySelector('style')
    const subs = await sdb.watch(onbatch)

    {
    menu_el.append(
        await btn1(subs[0]),
        await btn2(subs[1]),
        await btn3(subs[2]),
        await btn4(subs[3])
    )
    text_container_el.append(await text_module(subs[4]))
    }

    function onbatch (batch) {
    for (const { type, data } of batch) {
        on[type] && on[type](data)
    }
    }

    async function inject (data) {
    style_el.innerHTML = data.join('\n')
    }

    return el
}
