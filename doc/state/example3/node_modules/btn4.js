const STATE = require('../../../../src/node_modules/STATE')
const statedb = STATE(__filename)
const { sdb, subs: [get] } = statedb(fallback_module)

const textitle = 'Text from Button 4'

function fallback_module () {
    return {
    api: fallback_instance,
    drive: {
        lang: {
        'en-us.json': {
            raw: {
            label: 'Button 4'
            }
        }
        }
    }
    }
}
function fallback_instance () {
    return {}
}

module.exports = btn4
async function btn4 (opts) {
    const { id, sdb } = await get(opts.sid)
    const on = {
    lang: fill
    }

    const el = document.createElement('div')
    const shadow = el.attachShadow({ mode: 'closed' })
    shadow.innerHTML = `
    <button></button>
    <style>
        button {
        padding: 8px 16px;
        }
    </style>
    `
    const button_el = shadow.querySelector('button')
    const style_el = shadow.querySelector('style')
    const subs = await sdb.watch(onbatch)

    button_el.onclick = () => {
    const text_module_sdb = status.dataset_api['test_menu/index.js'].list('text').files[0]
    const text_module_state = db.read(['state', text_module_sdb])
    text_module_state.drive.text.raw = textitle
    db.add(['state', text_module_sdb], text_module_state)
    listeners[text_module_sdb]([{ type: 'text', data: [textitle] }]) // manually trigger update
    }

    function onbatch (batch) {
    for (const { type, data } of batch) {
        on[type] && on[type](data)
    }
    }

    async function fill (data) {
    button_el.textContent = data.label
    }
    return el
}
