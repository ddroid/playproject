const graphic = require('graphic')
/******************************************************************************
  OUR CONTRIBUTORS COMPONENT
******************************************************************************/
// ----------------------------------------
// MODULE STATE & ID
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
// ----------------------------------------
const default_opts = { }
const shopts = { mode: 'closed' }
// ----------------------------------------
module.exports = topnav

async function topnav (data, { port, css_id }) {
	// ----------------------------------------
	// ID + JSON STATE
	// ----------------------------------------
	const id = `${ID}:${count++}` // assigns their own name
	const status = {}
	const state = STATE.ids[id] = { id, status, wait: {}, net: {}, aka: {} } // all state of component instance
	const on_rx = {
		inject,
		inject_all,
		scroll
	}
	// ----------------------------------------
	// OPTS
	// ----------------------------------------

	const playLogo = await graphic('playLogo', './src/node_modules/assets/svg/logo.svg')
	// ----------------------------------------
	// TEMPLATE
	// ----------------------------------------
	const el = document.createElement('div')
	const shadow = el.attachShadow(shopts)
	shadow.innerHTML = `
		<section class='topnav'>
				<a href="#top">${playLogo.outerHTML}</a>
				<nav class='menu'>
				</nav>
		</section>
	`
	// ----------------------------------------
	const menu = shadow.querySelector('.menu')
	const body = shadow.querySelector('section')
	menu.append(...data.links.map(make_link))
	const scrollUp = 'scrollUp'
	const scrollDown = 'scrollDown'
	let lastScroll = 0
	
	window.addEventListener('scroll', ()=> {
		if (window.innerWidth >= 1024) {
			let currentScroll = window.pageYOffset
			if (currentScroll < 1) {
					body.classList.remove(scrollUp)
					body.classList.remove(scrollDown)
					return
			}
			if (currentScroll > lastScroll && !body.classList.contains(scrollDown)) {
					body.classList.add(scrollDown)
					body.classList.remove(scrollUp)
			} else if (currentScroll < lastScroll) {
					body.classList.add(scrollUp)
					body.classList.remove(scrollDown)
			}
			lastScroll = currentScroll
		}
	})

	window.addEventListener('resize', ()=> {
		if (window.innerWidth <= 1024) {
			body.classList.remove(scrollUp)
			body.classList.remove(scrollDown)
		}
	})
	// port.onmessage = onmessage
	init_css()
	return el

	async function onmessage ({ data }){
		on_rx[data.type](data)
	}
	function click(url) {
		port.postMessage({ type: 'jump', data: url })
	}
	async function inject ({ data }) {
		sheet.replaceSync(data)
		shadow.adoptedStyleSheets = [sheet]
	}
	function make_link(link){
		const a = document.createElement('a')
		a.href = `#${link.url}`
		a.textContent = link.text
		a.onclick = () => click(link.url)
		return a
	}
	async function init_css () {
		const pref = JSON.parse(localStorage.pref)
		const pref_shared = pref[name] || data.shared || []
		const pref_uniq = pref[css_id] || data.uniq || []
		pref_shared.forEach(async v => inject_all({ data: await get_theme(v)}))
		pref_uniq.forEach(async v => inject({ data: await get_theme(v)}))
	}
	async function scroll () {
		el.scrollIntoView({behavior: 'smooth'})
		el.tabIndex = '0'
		el.focus()
		el.onblur = () => {
			el.tabIndex = '-1'
			el.onblur = null
		}
	}
	async function inject_all ({ data }) {
		const sheet = new CSSStyleSheet
		sheet.replaceSync(data)
		shadow.adoptedStyleSheets.push(sheet)
	}
	async function inject ({ data }){
		const style = document.createElement('style')
		style.innerHTML = data
		shadow.append(style)
	}
	async function get_theme ({local = true, theme = 'default', id}) {
		let theme_css
		if(local)
			theme_css = await (await fetch(`./src/node_modules/css/${theme}/${id}.css`)).text()
		else
			theme_css = JSON.parse(localStorage[theme])[name][id]
		return theme_css
	}
}
