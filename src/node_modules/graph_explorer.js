/******************************************************************************
  GRAPH COMPONENT
******************************************************************************/
// ----------------------------------------
// MODULE STATE & IDd
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
// ----------------------------------------
const default_opts = { }
const shopts = { mode: 'closed' }
// ----------------------------------------

module.exports = graph_explorer

async function graph_explorer (data, { port, css_id }) {
  // ----------------------------------------
  // ID + JSON STATE
  // ----------------------------------------
  const id = `${ID}:${count++}` // assigns their own name
  const name = 'graph_explorer'
  const status = { tab_id: 0 }
  const state = STATE.ids[id] = { id, status, wait: {}, net: {}, aka: {}, channels: {}} // all state of instance instance
  const on_rx = {
    init,
    inject,
    inject_all,
    scroll
  }
  const on_add = {
    'io': add_node_io,
    'link': add_node_link,
    'tasks': add_node_sub,
  }
  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div')
  const shadow = el.attachShadow(shopts)
  shadow.innerHTML = `
  <main>

  </main>
  `
  const main = shadow.querySelector('main')
  port.onmessage = e => on_rx[e.data.type](e.data)
  init_css()
  return el

  async function init ({ data }) {
    status.graph = data
    const root_nodes = data.filter(node => !node.hub)
    main.append(...root_nodes.map((data, i) => add_node_root({data, last: i === root_nodes.length - 1 })))
  }
  function create_node (type, id) {
    const element = document.createElement('div')
    element.classList.add(type, 'node')
    element.tabIndex = '0'
    element.id = 'a'+id
    return element
  }
  function html_template (data, last, space, grand_last){
    const element = create_node(data.type, data.id)
    if(data.hub)
      space += grand_last ? '&emsp;&emsp;' : 'â”‚&emsp;&nbsp;'
    else
      space = ''
    element.dataset.space = space
    element.dataset.grand_last = last ? 'a' : ''

    return [element, last, space]
  }
  /******************************************
   Addition Operation
  ******************************************/
  function add_node_el ({ data, parent, space, grand_last, type }){
    const is_single = parent.children.length ? false : true
    if(data.root){
      parent.prepend(add_node_root({ data, last: false}))
      return
    }
    //hub or sub node check
    if(type === 'inputs')
      parent.append(on_add[type]({ data, space, grand_last, first: is_single}))
    else
      parent.prepend(on_add[type]({ data, space, grand_last, last: is_single}))

  }
  function add_node_root ({ data, last }) {
    [ element, last, space ] = html_template(data, last)
    element.innerHTML = `
      <div class="details">
        ${last ? 'â””' : 'â”œ'}<span class="tas">ðŸ““â”€</span><span class="name">${data.name}</div>
      </div>
      <div class="tasks nodes">
      </div>
    `
    const details = element.querySelector('.details > .name')
    const sub_emo = element.querySelector('.details > .tas')
    const tasks = element.querySelector('.tasks')
    
    let is_on
    sub_emo.onclick = sub_click
    details.onclick = () => {
      port.postMessage({type: 'send', to_type: 'open_editor', to: 0, data})
    }
    // element.onfocus = handle_focus
    return element
    function sub_click () {
      sub_emo.innerHTML = is_on ? 'ðŸ““â”€' : 'ðŸ“–â”¬'  
      is_on = handle_click({ el: tasks, type: 'tasks', data: data.sub, space, is_on, grand_last: last, pos: false })
    }
  }
  function add_node_sub ({ data, last, grand_last, space }) {
    [ element, last, space ] = html_template(data, last, space, grand_last)
    
    element.innerHTML = `
      <div class="hub nodes">
      </div>
      <div class="inputs nodes">
      </div>
      <div class="details">
        ${space}${last ? 'â””' : 'â”œ'}<span class="hub_emo">ðŸ“ª</span><span class="tas">â”€ðŸ“ª</span><span class="inp">ðŸ—ƒ</span><span class="out">â”€ðŸ—ƒ</span><span class="name">${data.name}</span>
      </div>
      <div class="outputs nodes">
      </div>
      <div class="tasks nodes">
      </div>
    `
    const details = element.querySelector('.details > .name')
    const hub_emo = element.querySelector('.details > .hub_emo')
    const sub_emo = element.querySelector('.details > .tas')
    const inp = element.querySelector('.details > .inp')
    const out = element.querySelector('.details > .out')
    // const after = element.querySelector('.details > .after')
    const hub = element.querySelector('.hub')
    const outputs = element.querySelector('.outputs')
    const inputs = element.querySelector('.inputs')
    const tasks = element.querySelector('.tasks')
    
    let hub_on, sub_on, inp_on, out_on
    hub_emo.onclick = hub_click
    sub_emo.onclick = sub_click
    inp.onclick = inp_click
    out.onclick = out_click
    details.onclick = () => {
      port.postMessage({type: 'send', to_type: 'open_editor', to: 0, data})
    }
    return element
    function hub_click () {
      if(hub_on){
        hub_emo.innerHTML = 'ðŸ“ª'
        sub_on ? sub_emo.innerHTML = 'â”¬'+sub_emo.innerHTML.slice(1) : sub_emo.innerHTML = 'â”€'+sub_emo.innerHTML.slice(1)
      } else{
        hub_emo.innerHTML = 'ðŸ“­'
        sub_on ? sub_emo.innerHTML = 'â”¼'+sub_emo.innerHTML.slice(1) : sub_emo.innerHTML = 'â”´'+sub_emo.innerHTML.slice(1)
      }
      hub_on = handle_click({ el: hub, type: 'link', data: data.hub, space, is_on: hub_on, pos: true })
    }
    function sub_click () {
      if(sub_on){
        hub_on ? sub_emo.innerHTML = 'â”´ðŸ“ª' : sub_emo.innerHTML = 'â”€ðŸ“ª'
      } else{
        hub_on ? sub_emo.innerHTML = 'â”¼ðŸ“­' : sub_emo.innerHTML = 'â”¬ðŸ“­'
      }
      sub_on = handle_click({ el: tasks, type: 'tasks', data: data.sub, space, is_on: sub_on, grand_last: last, pos: false })
    }
    function inp_click () {
      if(inp_on){
        inp.innerHTML = 'ðŸ—ƒ'
        out_on ? out.innerHTML = 'â”¬'+out.innerHTML.slice(1) : out.innerHTML = 'â”€'+out.innerHTML.slice(1)
      } else{
        inp.innerHTML = 'ðŸ—‚'
        out_on ? out.innerHTML = 'â”¼'+out.innerHTML.slice(1) : out.innerHTML = 'â”´'+out.innerHTML.slice(1)
      }
      inp_on = handle_click({ el: inputs, type: 'io', data: data.inputs, space, is_on: inp_on, pos: true })
    }
    function out_click () {
      if(out_on){
        inp_on ? out.innerHTML = 'â”´ðŸ—ƒ' : out.innerHTML = 'â”€ðŸ—ƒ'
      } else{
        inp_on ? out.innerHTML = 'â”¼ðŸ—‚' : out.innerHTML = 'â”¬ðŸ—‚'
      }
      out_on = handle_click({ el: outputs, type: 'io', data: data.outputs, space, is_on: out_open, pos: false })
    }
  }
  function add_node_io ({ data, first, last, space }) {
    const element = create_node(data.type, data.id)
    const grand_space = space + 'â”‚&emsp;&nbsp;â”‚&emsp;&emsp;&ensp;'
    space += 'â”‚&emsp;&emsp;&emsp;&emsp;&ensp;'
    element.innerHTML = `
    <div class="details">
      <span class="space">${space}</span><span class="grand_space">${grand_space}</span>${first ? 'â”Œ' : last ? 'â””' : 'â”œ'}</span><span class="btn">ðŸ“¥â”€</span>${data.name}<span class="after">ðŸ”—</span>
    </div>
    <div class="tasks nodes">
    </div>
    `
    const btn = element.querySelector('.details > .btn')
    const tasks = element.querySelector('.tasks')
    btn.onclick = () => handle_click({ el: tasks, type: 'link', data: data.sub, space, pos: false })
    return element
  }
  function add_node_link ({ data, first, last, space }) {
    const element = document.createElement('div')
    element.classList.add('next', 'node')
    element.dataset.id = data.id
    space += 'â”‚&emsp;&nbsp;'
    element.innerHTML = `
      <div class="details">
        ${space}${last ? 'â””' : first ? 'â”Œ' : 'â”œ'} ${data.name}
      </div>`
    element.onclick = jump
    
    return element
  }
  async function add_node_data (name, type, parent_id, users, author){
    const node_id = status.graph.length
    status.graph.push({ id: node_id, name, type: state.code_words[type], room: {}, users })
    if(parent_id){
      save_msg({
          head: [id],
          type: 'save_msg',
          data: {username: 'system', content: author + ' added ' + type.slice(0,-1)+': '+name, chat_id: parent_id}
        })
      //Add a message in the chat
      if(state.chat_task && parent_id === state.chat_task.id.slice(1))
        channel_up.send({
          head: [id, channel_up.send.id, channel_up.mid++],
          type: 'render_msg',
          data: {username: 'system', content: author+' added '+type.slice(0,-1)+': '+name}
        })
      const sub_nodes = graph[parent_id][state.add_words[type]]
      sub_nodes ? sub_nodes.push(node_id) : graph[parent_id][state.add_words[type]] = [node_id]
    }
    else{
      graph[node_id].root = true
      graph[node_id].users = [opts.host]
    }
    save_msg({
      head: [id],
      type: 'save_msg',
      data: {username: 'system', content: author + ' created ' + type.slice(0,-1)+': '+name, chat_id: node_id}
    })
    const channel = state.net[state.aka.taskdb]
    channel.send({
      head: [id, channel.send.id, channel.mid++],
      type: 'set',
      data: graph
    })
    
  }
  async function on_add_node (data) {
    const node = data.id ? shadow.querySelector('#a' + data.id + ' > .'+data.type) : tree_el
    node && node.children.length && add_node_el({ data: { name: data.name, id: status.graph.length, type: state.code_words[data.type] }, parent: node, grand_last: data.grand_last, type: data.type, space: data.space })
    add_node_data(data.name, data.type, data.id, data.users, data.user)
  }
  /******************************************
   Event handlers
  ******************************************/
  function handle_focus (e) {
    state.xtask = e.target
    state.xtask.classList.add('focus')
    state.xtask.addEventListener('blur', e => {
      if(e.relatedTarget && e.relatedTarget.classList.contains('noblur'))
        return
      state.xtask.classList.remove('focus')
      state.xtask = undefined
    }, { once: true })
  }
  function handle_popup (e) {
    const el = e.target
    el.classList.add('show')
    popup.style.top = el.offsetTop - 20 + 'px'
    popup.style.left = el.offsetLeft - 56 + 'px'
    popup.focus()
    popup.addEventListener('blur', () => {
      el.classList.remove('show')
    }, { once: true })
  }
  function handle_click ({ el, type, data, space, is_on, grand_last, pos }) {
    el.classList.toggle('show')
    if(data && el.children.length < 1){
      length = data.length - 1
      data.forEach((value, i) => el.append(on_add[type]({ data: status.graph[value], first: pos ? 0 === i : false, last: pos ? false : length === i, space, grand_last })))
    }
    return !is_on
  }
  async function handle_export () {
    const data = await traverse( state.xtask.id.slice(1) )
    const json_string = JSON.stringify(data, null, 2);
    const blob = new Blob([json_string], { type: 'application/json' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'data.json';
    link.click();
  }
  async function handle_add (data) {
    data = data.slice(2).trim().toLowerCase() + 's'
    const input = document.createElement('input')
    let node, task_id, space = '', grand_last = true, root = true
    //expand other siblings
    if(state.xtask){
      node = state.xtask.querySelector('.' + data)
      task_id = state.xtask.id.slice(1)
      const before = state.xtask.querySelector('.' + data.slice(0,3))
      before.dispatchEvent(new MouseEvent('click', {bubbles:true, cancelable: true, view: window}))
      node.classList.add('show')
      grand_last = state.xtask.dataset.grand_last
      space = state.xtask.dataset.space
      state.xtask.classList.remove('focus')
      state.xtask = undefined
      root = false
    }
    else{
      node = tree_el
      task_id = ''
    }
    node.prepend(input)
    input.onkeydown = async (event) => {
      if (event.key === 'Enter') {
        input.blur()
        add_node_el({ data : { name: input.value, id: status.graph.length, type: state.code_words[data], root }, space, grand_last, type: data, parent: node })
        const users = task_id ? graph[task_id].users : [host]
        add_node_data(input.value, data, task_id, users, host)
        //sync with other users
        if(users.length > 1)
          channel_up.send({
            head: [id, channel_up.send.id, channel_up.mid++],
            type: 'send',
            data: {to: 'task_explorer', route: ['up', 'task_explorer'], users: graph[task_id].users.filter(user => user !== host), type: 'on_add_node', data: {name: input.value, id: task_id, type: data, users, grand_last, space, user: host} }
          })
      }
    }
    input.focus()
    input.onblur = () => input.remove()
  }
  /******************************************
   Tree traversal
  ******************************************/
  async function jump (e){
    let target_id = e.currentTarget.dataset.id
    const el = tree_el.querySelector('#a'+target_id)
    if(el)
      el.focus()
    else{
      const path = []
      for(let temp = graph[target_id]; !temp.root; temp = graph[temp.parent])
        path.push(temp.id)
      temp = tree_el.querySelector('#a'+temp.id)
      target_id = 'a'+target_id
      while(temp.id !== target_id){
        const before = temp.querySelector('.before')
        before.dispatchEvent(new MouseEvent('click', {bubbles:true, cancelable: true, view: window}))
        temp.classList.add('show')
        temp = temp.querySelector('#a'+path.pop())
      }
      temp.focus()
    }
      
  }
  async function traverse (id) {
    state.result = []
    state.track = []
    recurse(id)
    return state.result
  }
  function recurse (id){
    if(state.track.includes(id))
      return
    state.result.push(graph[id])
    state.track.push(id)
    for(temp = 0; graph[id].tasks && temp < graph[id].tasks.length; temp++)
      recurse(graph[id].tasks[temp])
    for(temp = 0; graph[id].inputs && temp < graph[id].inputs.length; temp++)
      recurse(graph[id].inputs[temp])
    for(temp = 0; graph[id].outputs && temp < graph[id].outputs.length; temp++)
      recurse(graph[id].outputs[temp])
  }
  /******************************************
   Communication
  ******************************************/
  async function open_chat () {
    const node = graph[Number(state.xtask.id.slice(1))]
    channel_up.send({
      head: [id, channel_up.send.id, channel_up.mid++],
      type: 'open_chat',
      data: node
    })
    
    if(state.chat_task)
      state.chat_task.classList.remove('chat_active')
    state.chat_task = state.xtask
    state.chat_task.classList.add('chat_active')
  }
  async function save_msg (msg) {
    const {data} = msg
    msg.data = data.content,
    msg.meta = {
        date: new Date().getTime()
      }
    msg.refs = ''
    const node = graph[Number(data.chat_id)]
    const username = data.username === host ? '' : data.username
    node.room[username] ? node.room[username].push(msg) : node.room[username] = [msg]
    const channel = state.net[state.aka.taskdb]
    channel.send({
      head: [id, channel.send.id, channel.mid++],
      type: 'set',
      data: graph
    })
  }
  async function handle_invite ({ sender, task_id }) {
    const node = graph[Number(task_id)]
    node.users.push(sender)
    channel_up.send({
      head: [id, channel_up.send.id, channel_up.mid++],
      type: 'send',
      data: {to: 'task_explorer', route: ['up', 'task_explorer'], users: [sender], type: 'on_invite', data: node }
    })
  }
  async function on_invite (data) {
    const {name, id, type} = data
    tree_el.prepend(add_node_sub({ name, id, type }))
    status.graph.push(data)
  }
  async function send ({ data }) {
    const {to, route} = data
    if(to === state.name){
      const {type, data: shuttle_data} = data
      on[type](shuttle_data)
      return
    }
    const channel = state.net[state.aka[route[0]]]
    data.route = data.route.slice(1)
    channel.send({
      head: [id, channel.send.id, channel.mid++],
      type: 'send',
      data
    })
  }
  async function init_css () {
    const pref = JSON.parse(localStorage.pref)
    const pref_shared = pref[name] || data.shared || []
    const pref_uniq = pref[css_id] || data.uniq || []
    console.log(data)
    pref_shared.forEach(async v => inject_all({ data: await get_theme(v)}))
    pref_uniq.forEach(async v => inject({ data: await get_theme(v)}))
  }
  async function scroll () {
    el.scrollIntoView({behavior: 'smooth'})
    el.tabIndex = '0'
    el.focus()
    el.onblur = () => {
      el.tabIndex = '-1'
      el.onblur = null
    }
  }
  async function inject_all ({ data }) {
    const sheet = new CSSStyleSheet
    sheet.replaceSync(data)
    shadow.adoptedStyleSheets.push(sheet)
  }
  async function inject ({ data }){
    const style = document.createElement('style')
    style.innerHTML = data
    shadow.append(style)
  }
  async function get_theme ({local = true, theme = 'default', id}) {
    let theme_css
    if(local)
      theme_css = await (await fetch(`./src/node_modules/css/${theme}/${id}.css`)).text()
    else
      theme_css = JSON.parse(localStorage[theme])[name][id]
    return theme_css
  }
}