// STATE.js
var data, xdata
const s2i = {}
const i2s ={}

module.exports = STATE

function STATE () {
  const deny = []
  return { get, init }
  function get (sid) {
    if (deny.includes(sid)) throw new Error('access denied')
    const item = xdata[s2i[sid]]
    item.sub && Object.values(item.sub).forEach(sids => {
      if(typeof(sid) === 'object')
        deny.push(...sids)
      else
        deny.push(sids)
    })
    if(s2i[sid] === '11')
      return {data: item, xget, add, get_id}
    return item
  }
  function xget (sid) {
    return data[s2i[sid]]
  }
  function get_id (id) {
    return data[id]
  }
  function add (instance) {
    const id = Object.keys(data).length
    instance = JSON.parse(instance)
    data[id] = instance
    xdata[id] = instance
    idfy(id)
    data[instance.hub].sub[instance.comp].push(id)
    xdata[instance.hub].sub[instance.comp].push(i2s[id])
    return i2s[id]
  }
  async function init (datapath) {
    STATE.init = undefined
    if (data) throw new Error('Access denied')
    data = await (await fetch(datapath)).json()
    xdata = JSON.parse(JSON.stringify(data))
    Object.keys(data).forEach(idfy)
    Object.entries(data).forEach(assign)
    return i2s['0']
  }
  function idfy (id) {
    const sid = Symbol(id)
    s2i[sid] = id
    i2s[id] = sid
  }
  function assign(entry){
    entry[1].sub && Object.entries(entry[1].sub).forEach(item => {
      if(typeof(item[1]) === 'object'){
        xdata[entry[0]].sub[item[0]] = []
        item[1].forEach(id => {
          xdata[entry[0]].sub[item[0]].push(i2s[id])
        })
      }
      else{
        xdata[entry[0]].sub[item[0]] = i2s[item[1]]
      }
    })
  }
}