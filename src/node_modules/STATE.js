// STATE.js

const snapshot = require('../../snapshot.json')
const localdb = require('localdb')
const db = localdb()
const status = {root_module: true, root_instance: true}

if(db.read(['playproject_version']) != 3){
  localStorage.clear()
  status.snapshot = true
  db.add(['playproject_version'], 3)
}
// db.read(['state']) || db.add(['state'], {})

const listeners = {}
const s2i = {}
const i2s = {}
var admins = [0]

module.exports = STATE
function STATE(filename) {
  const parts = filename.split('/node_modules/')
  const last = parts.at(-1).split('/')
  let modulename = last.at(-1).slice(0, -3)
  let data
  const deny = {}, subs = {}
  const sdb = { on, get_sub, req_access }
  const admin = { xget, get_all, add_admins }
  return statedb

  function statedb (fallback) {
    data = db.get_by_value(['state'], {'name': modulename, type: 'module'})
    if(status.snapshot || !data){
      if (status.root_module){
        status.snapshot = !snapshot
        snapshot ? db.append(['state'], snapshot) : preprocess(fallback())
        status.root_module = false
      }
      else
        preprocess(fallback())
      data = db.get_by_value(['state'], {'name': modulename, type: 'module'})
    }
    if(data.id == 0){
      data.admins && add_admins(data.admins)
    }
    // data.slot.hubs && add_source(data.slot.hubs)
    return { id: data.id, sdb, getdb }
  }
  function add_source(hubs){
    hubs.forEach(id => {
      const data = db.read(['state', id])
      if(data.type === 'js'){
        fetch_save(data)
      }
    })
  }
  function symbolfy (data){
    data.slot.subs && data.slot.subs.forEach(sub => {
      const substate = db.read(['state', sub])
      s2i[i2s[sub] = Symbol(sub)] = sub
      subs[substate.xtype]?.push(i2s[sub]) || (subs[substate.xtype] = [i2s[sub]])
    })
  }
  function getdb (sid, fallback){
    const id = s2i[sid]
    data = db.read(['state', id])
    if(status.snapshot || !data){
      preprocess_instance(fallback(), id)
      data = db.read(['state', id])
    }
    if(status.root_instance){
      data = db.get_by_value(['state'], {'name': modulename, type: 'instance'})
      status.root_instance = false
    }
    symbolfy(data)
    return {id, sdb}
  }
  async function on (local_listeners) {
    listeners[data.id] = local_listeners
    const input_map = {}
    data.slot.inputs && await Promise.all(data.slot.inputs.map(async input => {
      const input_state = db.read(['state', input])
      const input_data = await fetch_save(input_state)
      input_map[input_state.type]?.push(input_data) || (input_map[input_state.type] = [input_data])
    }))
    local_listeners && Object.entries(local_listeners).forEach(([datatype, listener]) => {
      input_map[datatype] && listener(input_map[datatype])
    })
    return subs
  }
  async function fetch_save({ id, name, file, type, data }) {
    const xtype = (typeof(id) === "number" ? name : id).split('.').at(-1)
    let result = db.read([ type, id ])
    if(!result){
      result = data || await((await fetch(file))[xtype === 'json' ?'json' :'text']())
      db.add([type, id], result)
    }
    return result
  }
  function get_sub (name) {
    return subs[name]
  }
  async function add_admins (ids) {
    admins.push(...ids)
  }
  function req_access (sid) {
    if (deny[sid]) throw new Error('access denied')
    const el = db.read(['state', s2i[sid]])
    if(admins.includes(s2i[sid]) || admins.includes(el?.name))
      return admin
  }
  function xget (id) {
    return db.read(['state', id])
  }
  function get_all () {
    return db.read_all(['state'])
  }
  function preprocess (raw_data) {
    let id = db.length(['state'])
    clean(raw_data[0])
    
    function clean (entry) {
      entry.id = id
      entry.name = modulename
      entry.type = 'module'
      db.add(['state', id], entry)
      const file = raw_data[entry.slot.hubs[0]]
      file.id = entry.slot.hubs[0]
      db.add(['state', file.id], file)
    }
  }
  function preprocess_instance (raw_data, new_id) {
    let count = db.length(['state'])
    const on = {
      subs: clean_instance,
      inputs: clean_file
    }
    clean_instance(0)

    function clean_instance (entry_id) {
      const entry = raw_data[entry_id]
      entry.id = entry_id ? count++ : new_id
      entry.name = entry.name || modulename
      entry.type = 'instance'
      entry.xtype = entry.name
      const new_slot = {}
      Object.entries(entry.slot).forEach(([slot, ids]) => {
        const new_ids = []
        if(Object.keys(on).includes(slot))
          ids.forEach(id => new_ids.push(on[slot](id)))
        new_slot[slot] = new_ids
      })
      entry.slot = new_slot
      db.add(['state', entry.id], entry)
      return entry.id
    }
    function clean_file (file_id){
      const file = raw_data[file_id]
      file.id = file_id
      file.type = file.type || file.id.split('.').at(-1)
      db.add(['state', file_id], file)
      return file_id
    }
  }
  
}





//
//DUMP
//
async function pinit (url) {
  if (!STATE.init) throw new Error('already initialized')
  STATE.init = undefined
  Object.freeze(STATE)
  let data = db.read(['state'])
  if(!data){
    const res = await fetch(url)
    data = res.ok && await (res).json()
    db.add(['state'], data || {
      "0": {
        id: "0"
      }
    })
  }
  const length = db.length(['state'])
  for (var id = 0; id < length; id++) s2i[i2s[id] = Symbol(id)] = id
  return i2s[0]
  async function reset () {
    await db.clear()
  }
}
function static () {
  const sdb = { get, req_access }
  const deny = {}
  return sdb

  function symbolfy (data) {
    data?.sub && Object.entries(data.sub).forEach(assign)
    return data

    function assign([comp, ids]){
      if(typeof(ids) === 'object'){
        data.sub[comp] = []
        ids.forEach(id => {
          data.sub[comp].push(i2s[id])
          deny[i2s[id]] = true
        })
      }
      else{
        data.sub[comp] = i2s[ids]
        deny[i2s[ids]] = true
      }
    }
  }
  async function get (sid, fallback) {
    if (deny[sid]) throw new Error('access denied')
    const id = s2i[sid]
    let xnode = db.read(['state', id])
    if(Object.keys(xnode).length < 2)
      xnode = preprocess(await fallback())[id]
    return symbolfy(xnode)
  }
  function preprocess (local_data) {
    let count = db.length(['state'])
      Object.values(local_data)[0].id = id
      local_data[id] = Object.values(local_data)[0]
      id && delete(local_data[0])

      Object.values(local_data).forEach(node => {
        node.sub && Object.entries(node.sub).forEach(([comp, list]) => {
          node.sub[comp] = []
          list.forEach(id => {
            if(Number(id) > count){
              s2i[i2s[id] = Symbol(id)] = id
              local_data[id].id = id
              node.sub[comp].push(id)
            }
            else{
              s2i[i2s[count] = Symbol(count)] = count
              local_data[count] = local_data[id] || {}
              local_data[count].id = count
              id.includes('x') && delete(local_data[id])
              node.sub[comp].push(count++)
            }
          })
        })
      })
      db.append(['state'], local_data)
      return local_data
  }
  function req_access(sid) {
    if (deny[sid]) throw new Error('access denied')
    const el = db.read(['state', s2i[sid]])
    if(admins.includes(s2i[sid]) || admins.includes(el?.comp))
      return { xget, set_admins }
  }
  function xget(id) {
    return db.read(['state', id])
  }
  async function set_admins(ids) {
    admins = ids
  }
}