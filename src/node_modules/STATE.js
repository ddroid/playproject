// STATE.js

const localdb = require('localdb')
const db = localdb()
const status = {
  root_module: true, 
  root_instance: true, 
  module_index: {}, 
  overrides: {},

}
const default_slots = ['hubs', 'subs', 'inputs', 'outputs']

const version = 8
if(db.read(['playproject_version']) != version){
  console.log(db.read(['playproject_version']))
  localStorage.clear()
  status.fallback_check = true
  db.add(['playproject_version'], version)
}
// db.read(['state']) || db.add(['state'], {})

const listeners = {}
const s2i = {}
const i2s = {}
var admins = [0]

module.exports = STATE
function STATE(filename) {
  const parts = filename.split('/node_modules/')
  const last = parts.at(-1).split('/')
  const local_status = {
    name: last.at(-1).slice(0, -3),
    deny: {}, subs: []
  }
  const sdb = { watch, get_sub, req_access }
  const subs = [get]
  const admin = { xget, get_all, add_admins, load }
  return statedb

  function statedb (fallback) {
    local_status.fallback = fallback
    const search_filters = {'type': local_status.name}
    data = db.get_by_value(['state'], search_filters, status.module_index[local_status.name])
    if (status.fallback_check) {
      if (status.root_module) {
        preprocess(fallback(), 'module', {id: 0})
        status.root_module = false
      }
      else
        preprocess(fallback(), 'module', data)
      data = db.get_by_value(['state'], search_filters, status.module_index[local_status.name])
    }
    if(data.id == 0){
      data.admins && add_admins(data.admins)
    }
    local_status.id = data.id
    local_status.module_id = data.id
    data.hubs && add_source(data.hubs)
    const sub_modules = {}
    data.subs && data.subs.forEach(id => {
      sub_modules[db.read(['state', id]).type] = id
    })
    return { id: data.id, sdb, subs, sub_modules }
  }
  function add_source (hubs) {
    hubs.forEach(id => {
      const data = db.read(['state', id])
      if(data.type === 'js'){
        fetch_save(data)
      }
    })
  }
  function symbolfy (data) {
    data.subs && data.subs.forEach(sub => {
      const substate = db.read(['state', sub])
      s2i[i2s[sub] = Symbol(sub)] = sub
      local_status.subs.push({ sid: i2s[sub], type: substate.type })
    })
  }
  function load (snapshot) {
    localStorage.clear()
    Object.entries(snapshot).forEach(([key, value]) => {
      db.add([key], JSON.parse(value), true)
    })
    window.location.reload()
  }
  function get (sid) {
    const id = s2i[sid]
    data = db.read(['state', id])
    if(status.fallback_check){
      preprocess(local_status.fallback(), 'instance', data)
      data = db.read(['state', id])
    }
    if(status.root_instance){
      data = db.get_by_value(['state'], {'type': 0})
      status.root_instance = false
    }
    local_status.id = data.id
    symbolfy(data)
    return {id, sdb}
  }
  async function watch (listener) {
    const data = db.read(['state', local_status.id])
    listeners[data.id] = listener
    const input_map = []
    data.inputs && await Promise.all(data.inputs.map(async input => {
      const input_state = db.read(['state', input])
      const input_data = await fetch_save(input_state)
      input_map.push({ type: input_state.type, data: [input_data] })
    }))
    listener(input_map)
    return local_status.subs
  }
  async function fetch_save({ id, name, $ref, type, data }) {
    const xtype = (typeof(id) === "number" ? name : id).split('.').at(-1)
    let result = db.read([ type, id ])
    if(!result){
      result = data || await((await fetch($ref))[xtype === 'json' ?'json' :'text']())
      db.add([type, id], result)
    }
    return result
  }
  function get_sub (type) {
    return local_status.subs.filter(sub => {
      const dad = db.read(['state', sub.type])
      return dad.type === type
    })
  }
  async function add_admins (ids) {
    admins.push(...ids)
  }
  function req_access (sid) {
    if (local_status.deny[sid]) throw new Error('access denied')
    const el = db.read(['state', s2i[sid]])
    if(admins.includes(s2i[sid]) || admins.includes(el?.name))
      return admin
  }
  function xget (id) {
    return db.read(['state', id])
  }
  function get_all () {
    return db.read_all(['state'])
  }
  function preprocess (host_data, xtype, super_data = {}) {
    console.log('ok')
    let count = db.length(['state'])
    let {id: super_id, hubs, fallback, subs} = super_data
    let subs_data = {}, subs_types, id_map = {}
    if(subs){
      subs.forEach(id => subs_data[id] = db.read(['state', id]))
      subs_types = new Set(Object.values(subs_data).map(sub => sub.type))
    }
    fallback && fallback.forEach(handler_id => {
      host_data = status.overrides[handler_id](host_data)
    })

    const on = {
      subs: clean_node,
      inputs: clean_file,
      hubs: clean_file
    }
    clean_node(xtype === 'module' ? 0 : 1)

    function clean_node (local_id, hub_entry, hub_module) {
      const entry = host_data[local_id]
      let module

      if(Number(local_id) > 1){
        entry.hubs = [hub_entry.id]
        if(xtype === 'instance')
          hub_module?.subs && hub_module.subs.forEach(id => {
            const module_data = db.read(['state', id])
            if(module_data.idx == entry.type){
              entry.type = module_data.id
              module = module_data
              return
            }
          })
        else
          entry.idx = local_id
        //Check if sub-entries are already initialized by a super
        if(subs_types && subs_types.has(entry.type)){
          const super_entry = Object.values(subs_data).find(sub => sub.type == entry.type)
          //continue a fallback chain
          const index = super_entry?.fallback?.find(key => key == hub_entry.type)
          if(index){
            const key = 'f' + Object.keys(status.overrides).length
            super_entry.fallback[index] = key
            const fun = entry.fallback.find(v => typeof(v) === 'function')
            status.overrides[key] = fun
            db.add(['state', super_entry.id], super_entry)
          }
          return super_entry.id
        }
      }
      else{
        if(xtype === 'instance'){
          module = db.read(['state', local_status.module_id])
          entry.type = module.id
        }
        else{
          const file_id = local_status.name+'.js'
          host_data[file_id] = { $ref: new URL(filename, location).href }
          hubs?.push(file_id) || (hubs = [file_id])
          entry.type = entry.type || local_status.name
          entry.idx = super_data.idx
        }
        hubs && (entry.hubs = hubs)
      }
      entry.id = Number(local_id) > 1 ? count : super_id || count
      entry.name = entry.name || module?.type || entry.type || local_status.name

      id_map[local_id] = entry.type
      //start a fallback chain
      if(entry.fallback){
        const new_fallback = []
        entry.fallback.forEach(handler => {
          if(typeof(handler) === 'function'){
            const key = 'f' + Object.keys(status.overrides).length
            new_fallback.push(key)
            status.overrides[key] = handler
          }
          else
            new_fallback.push(id_map[handler])
        })
        entry.fallback = new_fallback
      }
      count++
      default_slots.forEach(slot => {
        if(entry[slot] && on[slot])
          entry[slot] = entry[slot].map(id => on[slot](id, entry, module))
      })
      db.add(['state', entry.id], entry)
      return entry.id
    }
    function clean_file (file_id, hub_entry){
      if(!isNaN(Number(file_id)))
        return file_id
      const file = host_data[file_id]
      file.id = file_id
      file.name = file.name || file_id
      file.type = file.type || file.id.split('.').at(-1)
      file[file.type === 'js' ? 'subs' : 'hubs' ] = [hub_entry.id]
      db.add(['state', file_id], file)
      return file_id
    }
  }
  
}