// STATE.js
const localdb = require('localdb')
const db = localdb()
db.read(['state']) || db.add(['state'], {})

const s2i = {}
const i2s = {}
var admins = [0]

module.exports = STATE
function STATE({ modulename }) {
  const deny = {}, uses = {}
  const sdb = { on, sub, req_access }
  const root_db = { populate }
  const admin = { xget, add_admins }
  return modulename ? statedb : statedb_root

  function statedb (fallback) {
    let data = db.get_by_value(['state'], 'code', modulename) || fallback(root_db)
    if(!data)
      data = db.read(['state'], 'code', modulename)
    return { id: data.id, sdb, getdb }
  }
  async function statedb_root (fallback) {
    let data = db.read(['state'])[1] || await fallback(root_db)
    if(!data)
      data = db.read(['state'])[1]
    symbolfy(data)
    add_admins(data.data.admins)
    return { id: data.id, sdb, getdb, admin }
  }
  function symbolfy(data){
    data.uses && Object.entries(data.uses).forEach(([comp, mods]) => {
      uses[comp] = []
      Object.values(mods).forEach(sub_ids => 
        sub_ids.forEach(sub_id => {
          s2i[i2s[sub_id] = Symbol(sub_id)] = sub_id
          uses[comp].push(i2s[sub_id])
        })
      )
    })
  }
  function getdb (sid, fallback){
    const id = s2i[sid]
    let data = db.read(['state', id]) || fallback(root_db)
    if(!data)
      data = db.read(['state', id])
    symbolfy(data)
    return {id, sdb}
  }
  function populate(data){
    db.append(['state'], data)
  }
  function on ({css, data}) {
    return uses
  }
  function sub (name) {
    return uses[name]
  }
  async function add_admins (ids) {
    admins.push(...ids)
  }
  function req_access(sid) {
    if (deny[sid]) throw new Error('access denied')
    const el = db.read(['state', s2i[sid]])
    console.log(admins, sid)
    if(admins.includes(s2i[sid]) || admins.includes(el?.name))
      return admin
  }
  function xget(id) {
    return db.read(['state', id])
  }
}

//DUMP
async function pinit (url) {
  if (!STATE.init) throw new Error('already initialized')
  STATE.init = undefined
  Object.freeze(STATE)
  let data = db.read(['state'])
  if(!data){
    const res = await fetch(url)
    data = res.ok && await (res).json()
    db.add(['state'], data || {
      "0": {
        id: "0"
      }
    })
  }
  const length = db.length(['state'])
  for (var id = 0; id < length; id++) s2i[i2s[id] = Symbol(id)] = id
  return i2s[0]
  async function reset () {
    await db.clear()
  }
}
function s () {
  const sdb = { get, req_access }
  const deny = {}
  return sdb

  function symbolfy (data) {
    data?.sub && Object.entries(data.sub).forEach(assign)
    return data

    function assign([comp, ids]){
      if(typeof(ids) === 'object'){
        data.sub[comp] = []
        ids.forEach(id => {
          data.sub[comp].push(i2s[id])
          deny[i2s[id]] = true
        })
      }
      else{
        data.sub[comp] = i2s[ids]
        deny[i2s[ids]] = true
      }
    }
  }
  async function get (sid, fallback) {
    if (deny[sid]) throw new Error('access denied')
    const id = s2i[sid]
    let xnode = db.read(['state', id])
    if(Object.keys(xnode).length < 2)
      xnode = preprocess(await fallback())[id]
    return symbolfy(xnode)
  }
  function preprocess (local_data) {
    let count = db.length(['state'])
      Object.values(local_data)[0].id = id
      local_data[id] = Object.values(local_data)[0]
      id && delete(local_data[0])

      Object.values(local_data).forEach(node => {
        node.sub && Object.entries(node.sub).forEach(([comp, list]) => {
          node.sub[comp] = []
          list.forEach(id => {
            if(Number(id) > count){
              s2i[i2s[id] = Symbol(id)] = id
              local_data[id].id = id
              node.sub[comp].push(id)
            }
            else{
              s2i[i2s[count] = Symbol(count)] = count
              local_data[count] = local_data[id] || {}
              local_data[count].id = count
              id.includes('x') && delete(local_data[id])
              node.sub[comp].push(count++)
            }
          })
        })
      })
      db.append(['state'], local_data)
      return local_data
  }
  function req_access(sid) {
    if (deny[sid]) throw new Error('access denied')
    const el = db.read(['state', s2i[sid]])
    if(admins.includes(s2i[sid]) || admins.includes(el?.comp))
      return { xget, set_admins }
  }
  function xget(id) {
    return db.read(['state', id])
  }
  async function set_admins(ids) {
    admins = ids
  }
}