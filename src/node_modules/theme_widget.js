/******************************************************************************
  THEME_WIDGET COMPONENT
******************************************************************************/
// ----------------------------------------
// MODULE STATE & ID
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
// ----------------------------------------
const sheet = new CSSStyleSheet
sheet.replaceSync(get_theme())
const default_opts = { }
const shopts = { mode: 'closed' }
// ----------------------------------------

module.exports = theme_widget

async function theme_widget(components, port) {
  port.onmessage = event => on_rx[event.data.type](event.data)
  // ----------------------------------------
  // ID + JSON STATE
  // ----------------------------------------
  const id = `${ID}:${count++}` // assigns their own name
  const status = {}
  const state = STATE.ids[id] = { id, status, wait: {}, net: {}, aka: {}, channels: {}} // all state of component instance
  status.dirts = JSON.parse(localStorage.dirt || (localStorage.dirt = '{}'))
  localStorage.pref || (localStorage.pref = '{}')
  status.themes = {
    local: ['default', 'dark'],
    saved: Object.entries(localStorage).filter(entry => {
      try{
        return JSON.parse(entry[1]).theme
      }
      catch{
        return false
      }
    }
    ).map(entry => entry[0])
  }
  const on_rx = {
    refresh
  }
  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div')
  const shadow = el.attachShadow(shopts)
  shadow.adoptedStyleSheets = [sheet]
  shadow.innerHTML = `
  <section>
    <div class="btn">
      ⚙️
    </div>
    <div class="popup">
      <div class="box">
        <div class="stats">
          Active components: 
        </div>
        <div class="list">
        </div>
      </div>
      <div class="editor">
        <h3></h3>
        <textarea></textarea>
        <select></select>
        <button class="load">
          Load
        </button>
        <button class="inject">
          Inject
        </button>
        <button class="save">
          Save
        </button>
        <button class="drop">
          Drop
        </button>
        <button class="reset">
          Reset
        </button>
        <input placeholder='Enter theme' />
        <button class="add">
          Add
        </button>
      </div>
    </div>
  </section>`
  const btn = shadow.querySelector('.btn')
  const popup = shadow.querySelector('.popup')
  const list = popup.querySelector('.list')
  const stats = popup.querySelector('.stats')
  const editor = popup.querySelector('.editor')
  const title = editor.querySelector('h3')
  const inject_btn = editor.querySelector('.inject')
  const load_btn = editor.querySelector('.load')
  const save_btn = editor.querySelector('.save')
  const add_btn = editor.querySelector('.add')
  const drop_btn = editor.querySelector('.drop')
  const reset_btn = editor.querySelector('.reset')
  const textarea = editor.querySelector('textarea')
  const dropdown = editor.querySelector('select')
  const input = editor.querySelector('input')

  btn.onclick = () => popup.classList.toggle('active')
  inject_btn.onclick = inject
  load_btn.onclick = load
  save_btn.onclick = save
  add_btn.onclick = add
  drop_btn.onclick = drop
  reset_btn.onclick = () => localStorage.clear()
  textarea.oninput = unsave
  update_dropdown()
  return el

  async function add () {
    localStorage[input.value] = '{"theme":"true","css":{}}'
    status.themes.saved.push(input.value)
    update_dropdown()
  }
  async function drop () {
    console.log('ok')
    localStorage.removeItem(dropdown.value)
    status.themes.saved = status.themes.saved.filter(v => v != dropdown.value)
    update_dropdown()
    dropdown.value = 'default'
    load()
  }
  async function forget_changes () {
    status.active_el.classList.remove('dirty')
    const dirt = JSON.parse(localStorage.dirt)
    delete(dirt[title.innerHTML])
    localStorage.dirt = JSON.stringify(dirt)
  }
  async function save () {
    forget_changes()
    const theme = localStorage[dropdown.value] && JSON.parse(localStorage[dropdown.value])
    if(theme){
      theme.css[title.innerHTML] = textarea.value
      localStorage[dropdown.value] = JSON.stringify(theme)
    }
    const pref = JSON.parse(localStorage.pref)
    pref[title.innerHTML] = dropdown.value
    localStorage.pref = JSON.stringify(pref)
  }
  async function unsave () {
    status.active_el.classList.add('dirty')
    let theme = localStorage[dropdown.value] && JSON.parse(localStorage[dropdown.value])
    if(theme){
      theme.css[title.innerHTML] = textarea.value
      localStorage[dropdown.value] = JSON.stringify(theme)
      const dirt = JSON.parse(localStorage.dirt)
      dirt[title.innerHTML] = dropdown.value
      localStorage.dirt = JSON.stringify(dirt)
    }
    else{
      const name = dropdown.value + '-v2'
      theme = localStorage[name] && JSON.parse(localStorage[name])
      if(theme){
        theme.css[title.innerHTML] = textarea.value
        localStorage[name] = JSON.stringify(theme)
        const dirt = JSON.parse(localStorage.dirt)
        dirt[title.innerHTML] = name
        localStorage.dirt = JSON.stringify(dirt)
      }
      else{
        theme = { theme: true, css: {} }
        theme.css[title.innerHTML] = textarea.value
        localStorage[name] = JSON.stringify(theme)
        status.themes.saved.push(name)
        const dirt = JSON.parse(localStorage.dirt)
        dirt[title.innerHTML] = name
        localStorage.dirt = JSON.stringify(dirt)
        update_dropdown()
        dropdown.value = name
      }
    }
  }
  async function inject () {
    port.postMessage({type: 'send', to_type: 'inject', to: status.active_id, data: textarea.value})
  }
  async function load () {
    const name = dropdown.value
    let theme
    if(status.themes.local.includes(name)){
      const temp = await fetch(`./src/node_modules/css/${name}/${title.innerHTML}.css`)
      theme = await temp.text()
    }
    else{
      theme = JSON.parse(localStorage[name]).css[title.innerHTML]
    }
    textarea.value = theme
    forget_changes()
  }
  async function refresh ({ data }) {
    status.tree = data
    stats.innerHTML = `Active components: ${Object.keys(data).length}`
    list.append(...Object.entries(data).filter(entry => entry[1].hub === '').map(make_node))
  }
  function make_node (component){
    const el = document.createElement('div')
    el.classList.add('item')
    if(Object.keys(status.dirts).includes(component[1].name)){
     el.classList.add('dirty') 
    }
    el.innerHTML = `<main><span class='pre'>+</span> <span class='name'>${component[1].name}</span></main> <div class="sub"></div>`
    const pre_btn = el.querySelector('.pre')
    const name_el = el.querySelector('.name')
    const sub = el.querySelector('.sub')
    pre_btn.onclick = () => {
      pre_btn.innerHTML = pre_btn.innerHTML === '+' ? '-' : '+'
      if(sub.children.length)
        sub.classList.toggle('hide')
      else
        sub.append(...Object.entries(status.tree).filter(entry => entry[1].hub == component[0]).map(make_node))
    }
    name_el.onclick = async () => {
      title.innerHTML = component[1].name
      if(status.active_id === component[0])
        editor.classList.toggle('active')
      else
        editor.classList.add('active')
      textarea.value = await get_css(component[1].name)
      status.active_id = component[0]
      status.active_el = el
    }
    return el
  }
  async function get_css (name) {
    const dirts = JSON.parse(localStorage.dirt)
    const dirt = dirts[name]
    const prefs = JSON.parse(localStorage.pref)
    const pref = prefs[name]
    let theme
    if(dirt || pref){
      if(Object.keys(localStorage).includes(dirt))
        theme = JSON.parse(localStorage[dirt]).css[name]      
      else if(Object.keys(localStorage).includes(pref))
        theme = JSON.parse(localStorage[pref]).css[name]
      else
        theme = await (await fetch(`./src/node_modules/css/${pref}/${name}.css`)).text()
    }
    else
      theme = await (await fetch(`./src/node_modules/css/default/${name}.css`)).text()
    dropdown.value = dirt || pref || 'default'
    return theme
  }
  async function update_dropdown () {
    dropdown.innerHTML = `<optgroup label='Local'>${status.themes.local.map(theme => `<option>${theme}</option>`)}</optgroup>` +
    `<optgroup label='Saved'> ${status.themes.saved.map(theme => `<option>${theme}</option>`)}</optgroup>`
  }
}

function get_theme() {
  return `
  *{
    box-sizing: border-box;
  }
  section{
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 50;
    display: flex;
    align-items: end;
  }
  .btn{
    font-size: 30px;
    cursor: pointer;
  }
  .popup{
    display: none;
    position: relative;
    bottom: 44px;
    margin-left: -42px;
    gap: 10px;
    align-items: end;
  }
  .popup.active{
    display: flex;
  }
  .popup .box{
    background: #beb2d7;
    border-radius: 5px;
    padding: 10px;
  }
  .popup .list{
    max-height: 60vh;
    overflow-y: scroll;
  }
  .popup .list .item{
    white-space: nowrap;
    cursor: pointer;
  }
  .popup .list .item > .sub{
    display: block;
    margin-left: 10px;
  }
  .popup .list .item > .sub.hide{
    display: none;
  }
  .popup .list .item > main:hover{
    background: #ada1c6;
  }
  .popup .list .item.dirty > main > .name{
    color: yellow;
  }
  .popup .editor{
    display: none;
    background: #beb2d7;
    position: relative;
    border-radius: 5px;
    padding: 10px;
  }
  .popup .editor.active{
    display: block;
  }
  .popup .editor textarea{
    min-height: 44vh;
    min-width: 100%;
  }
  `
}