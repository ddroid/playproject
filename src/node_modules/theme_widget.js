/******************************************************************************
  THEME_WIDGET COMPONENT
******************************************************************************/
// ----------------------------------------
// MODULE STATE & ID
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
// ----------------------------------------
const sheet = new CSSStyleSheet
sheet.replaceSync(get_theme())
const default_opts = { }
const shopts = { mode: 'closed' }
// ----------------------------------------

module.exports = theme_widget

async function theme_widget(instances, port, data) {
  port.onmessage = event => on_rx[event.data.type](event.data)
  // ----------------------------------------
  // ID + JSON STATE
  // ----------------------------------------
  const id = `${ID}:${count++}` // assigns their own name
  const status = { tab_id: 0 }
  const state = STATE.ids[id] = { id, status, wait: {}, net: {}, aka: {}, channels: {}} // all state of instance instance
  status.dirts = JSON.parse(localStorage.dirt || (localStorage.dirt = '{}'))
  localStorage.pref || (localStorage.pref = '{}')
  const paths =  JSON.parse(await(await fetch('./src/node_modules/css/index.json')).text())
  status.themes = {
    builtin: Object.keys(paths),
    saved: Object.keys(JSON.parse(localStorage.index || (localStorage.index = '{}')))
  }
  const on_rx = {
    refresh
  }
  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div')
  const shadow = el.attachShadow(shopts)
  shadow.adoptedStyleSheets = [sheet]
  shadow.innerHTML = `
  <section>
    <div class="btn">
      ⚙️
    </div>
    <div class="popup">
      <div class="box">
        <div class="stats">
          Instances: 
        </div>
        <button class="select">Select</button>
        <div class="list">
        </div>
      </div>
      <div class="editor">
        <h3>
        </h3>
        <div class="btns">
          <div class="box"></div>
          <span class="plus">+</span>
        </div>
        <div class="tabs">
        </div>
        <select class="theme"></select>
        <select class="type">
          <option>shared</option>
          <option>uniq</option>
        </select>
        <button class="load">
          Load
        </button>
        <button class="inject">
          Inject
        </button>
        <button class="save_file">
          Save file
        </button>
        <button class="save_pref">
          Save pref
        </button>
        <button class="drop">
          Drop
        </button>
        <button class="reset">
          Reset
        </button>
        <button class="export">
          Export
        </button>
        <button class="import">
          Import
        </button>
        <input style="display: none;" class="upload" type='file' />
        <input class="theme" placeholder='Enter theme' />
        <button class="add">
          Add
        </button>
      </div>
    </div>
  </section>`
  const btn = shadow.querySelector('.btn')
  const popup = shadow.querySelector('.popup')
  const list = popup.querySelector('.list')
  const stats = popup.querySelector('.stats')
  const editor = popup.querySelector('.editor')
  const select = popup.querySelector('.select')
  const inject_btn = editor.querySelector('.inject')
  const load_btn = editor.querySelector('.load')
  const save_file_btn = editor.querySelector('.save_file')
  const save_pref_btn = editor.querySelector('.save_pref')
  const add_btn = editor.querySelector('.add')
  const drop_btn = editor.querySelector('.drop')
  const reset_btn = editor.querySelector('.reset')
  const upload = editor.querySelector('.upload')
  const import_btn = editor.querySelector('.import')
  const export_btn = editor.querySelector('.export')
  const title = editor.querySelector('h3')
  const tabs = editor.querySelector('.tabs')
  const btns = editor.querySelector('.btns > .box')
  const plus = editor.querySelector('.plus')
  const select_theme = editor.querySelector('select.theme')
  const select_type = editor.querySelector('select.type')
  const input = editor.querySelector('input.theme')

  btn.onclick = () => popup.classList.toggle('active')
  inject_btn.onclick = inject
  load_btn.onclick = () => load(select_theme.value)
  save_file_btn.onclick = save_file
  save_pref_btn.onclick = save_pref
  add_btn.onclick = () => add(input.value)
  drop_btn.onclick = drop
  export_btn.onclick = export_fn
  import_btn.onclick = () => upload.click()
  upload.onchange = import_fn
  select.onclick = () => list.classList.toggle('active')
  reset_btn.onclick = () => localStorage.clear()
  plus.onclick = () => add_tab('New', '', 'uniq')
  // textarea.oninput = unsave
  update_select_theme()
  return el

  async function export_fn () {
    const theme = localStorage[select_theme.value]
    const blob = new Blob([JSON.stringify(JSON.parse(theme), null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = select_theme.value;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  async function import_fn () {
    const file = upload.files[0]
    const name = file.name.split('.')[0]
    await add(name)
    const reader = new FileReader();
    reader.onload = e => {
      localStorage[name] = e.target.result
      load(name)
    }
    reader.readAsText(file);
  }
  async function add (theme) {
    localStorage[theme] = '{}'
    status.themes.saved.push(theme)
    const index = JSON.parse(localStorage.index)
    index[theme] = {}
    localStorage.index = JSON.stringify(index)
    update_select_theme()
  }
  async function drop () {
    localStorage.removeItem(select_theme.value)
    status.themes.saved = status.themes.saved.filter(v => v != select_theme.value)
    update_select_theme()
    select_theme.value = 'default'
    load()
  }
  async function forget_changes () {
    status.active_el.classList.remove('dirty')
    const dirt = JSON.parse(localStorage.dirt)
    delete(dirt[status.title])
    localStorage.dirt = JSON.stringify(dirt)
  }
  async function save_file () {
    // forget_changes()
    const theme = localStorage[select_theme.value] && JSON.parse(localStorage[select_theme.value])
    if(theme){
      const index = JSON.parse(localStorage.index)
      theme[status.title] || (theme[status.title] = [], index[select_theme.value][status.title] = [])
      theme[status.title].push(status.textarea.value)
      index[select_theme.value][status.title].push(status.active_tab.dataset.name)
      localStorage[select_theme.value] = JSON.stringify(theme)
      localStorage.index = JSON.stringify(index)
    }
  }
  async function save_pref () {
    const pref = JSON.parse(localStorage.pref)
    if(select_type.value === "uniq"){
      pref[status.instance_id] || (pref[status.instance_id] = [])
      pref[status.instance_id].push({theme: select_theme.value, id:status.active_tab.dataset.id.split('_')[1], local: status.themes.builtin.includes(select_theme.value) })
    }
    else{
      pref[status.title] || (pref[status.title] = [])
      pref[status.title].push({theme: select_theme.value, id:status.active_tab.dataset.id.split('_')[1], local: status.themes.builtin.includes(select_theme.value) })
    }
    localStorage.pref = JSON.stringify(pref)
  }
  async function unsave () {
    status.active_el.classList.add('dirty')
    let theme = localStorage[select_theme.value] && JSON.parse(localStorage[select_theme.value])
    if(theme){
      theme.css[status.title] = textarea.value
      localStorage[select_theme.value] = JSON.stringify(theme)
      const dirt = JSON.parse(localStorage.dirt)
      dirt[status.title] = select_theme.value
      localStorage.dirt = JSON.stringify(dirt)
    }
    else{
      const name = select_theme.value + '*'
      theme = localStorage[name] && JSON.parse(localStorage[name])
      if(theme){
        theme.css[status.title] = textarea.value
        localStorage[name] = JSON.stringify(theme)
        const dirt = JSON.parse(localStorage.dirt)
        dirt[status.title] = name
        localStorage.dirt = JSON.stringify(dirt)
      }
      else{
        theme = { theme: true, css: {} }
        theme.css[status.title] = textarea.value
        localStorage[name] = JSON.stringify(theme)
        status.themes.saved.push(name)
        const dirt = JSON.parse(localStorage.dirt)
        dirt[status.title] = name
        localStorage.dirt = JSON.stringify(dirt)
        update_select_theme()
        select_theme.value = name
      }
    }
  }
  async function inject () {
    port.postMessage({type: 'send', to_type: select_type.value === 'uniq' ? 'inject' : 'inject_all', to: status.instance_id, data: status.textarea.value})
  }
  async function load (theme) {
    tabs.innerHTML = ''
    btns.innerHTML = ''
    let css
    if(status.themes.builtin.includes(theme)){
      const index = paths[theme][status.title].length
      for(let i = 0; i < index; i++){
        const temp = await fetch(`./src/node_modules/css/${theme}/${status.title}/${i}.css`)
        add_tab(`${status.title}_${i}`, await temp.text(), '', theme)
      }

    }
    else{
      const temp = JSON.parse(localStorage[theme])[status.title]
      temp.forEach((file, i) => {
          add_tab(`${status.title}_${i}`, file, '', theme)
      })
    }
    // forget_changes()
  }
  async function refresh ({ data }) {
    status.tree = data
    stats.innerHTML = `Active instances: ${Object.keys(data).length}`
    list.append(...Object.entries(data).filter(entry => entry[1].hub === '').map(make_node))
  }
  function make_node (instance){
    const el = document.createElement('div')
    el.classList.add('item')
    if(Object.keys(status.dirts).includes(instance[1].name)){
     el.classList.add('dirty') 
    }
    el.innerHTML = `<main><input type='checkbox' /><span class='pre'>➕</span> <span class='name'>${instance[0]}</span> <span class='post'>➡️</span></main> <div class="sub"></div>`
    const pre_btn = el.querySelector('.pre')
    const post_btn = el.querySelector('.post')
    const name_el = el.querySelector('.name')
    const sub = el.querySelector('.sub')
    pre_btn.onclick = () => {
      pre_btn.innerHTML = pre_btn.innerHTML === '➕' ? '➖' : '➕'
      if(sub.children.length)
        sub.classList.toggle('hide')
      else
        sub.append(...Object.entries(status.tree).filter(entry => entry[1].hub == instance[0]).map(make_node))
    }
    post_btn.onclick = () => {
      port.postMessage({type: 'send', to_type: 'scroll', to: instance[0]})
    }
    name_el.onclick = async () => {
      tabs.innerHTML = ''
      btns.innerHTML = ''
      status.title = instance[1].name
      title.innerHTML = instance[0]
      if(status.instance_id === instance[0])
        editor.classList.toggle('active')
      else
        editor.classList.add('active')
      // textarea.value = await get_css(instance[1].name)
      status.instance_id = instance[0]
      status.active_el = el
      status.active_path = instance[1].path
      init_css({...instance[1], id:instance[0]})
    }
    return el
  }
  async function init_css ({id, name, uniq, shared, hub}) {
    const pref = JSON.parse(localStorage.pref)
    const pref_shared = pref[name] || shared
    const pref_uniq = pref[id] || uniq
    await Promise.all(pref_shared.map(async v => await add_tab(`${name}_${v.id}`, await get_css(v, name), 'shared', v.theme)))
    await Promise.all(pref_uniq.map(async v => await add_tab(`${name}_${v.id}`, await get_css(v, name), 'uniq', v.theme)))
  }
  async function add_tab (id, css, type, theme = 'default') {
    const btn = document.createElement('span')
    const tab_id = 'a' + status.tab_id++
    btn.id = tab_id
    const split = id.split('_')
    const index = paths[theme] || JSON.parse(localStorage.index)[theme]
    btn.innerHTML = index[split[0]] ? index[split[0]][split[1]] : id
    btn.dataset.id = id
    btn.dataset.name = btn.innerHTML
    btn.dataset.theme = theme
    btn.dataset.type = type
    btns.append(btn)
    btn.onclick = () => switch_tab(btn.id)
    btn.ondblclick = () => {
      if(btn.children.length)
        return
      const input = document.createElement('input')
      input.value = btn.innerHTML
      btn.innerHTML = ''
      btn.append(input)
      input.onkeydown = rename
      input.onblur = e => {
        if(e.relatedTarget)
          btn.innerHTML = btn.dataset.name
      }
      input.focus()
    }
    const textarea = document.createElement('textarea')
    textarea.value = css
    textarea.id = tab_id
    tabs.append(textarea)
    switch_tab(tab_id)
  }
  async function switch_tab (tab_id) {
    status.textarea && status.textarea.classList.remove('active')
    status.textarea = tabs.querySelector('#' + tab_id)
    status.textarea.classList.add('active')
    status.active_tab && status.active_tab.classList.remove('active')
    status.active_tab = btns.querySelector('#' + tab_id)
    status.active_tab.classList.add('active')
    select_type.value = status.active_tab.dataset.type
    select_theme.value = status.active_tab.dataset.theme
  }
  async function get_css ({ local = true, theme = 'default', id }, name) {
    let theme_css
    if(local)
      theme_css = await (await fetch(`./src/node_modules/css/${theme}/${name}/${id}.css`)).text()
    else
      theme_css = JSON.parse(localStorage[theme])[name][id]
    return theme_css
  }
  async function rename (e) {
    if(e.key === 'Enter'){
      status.active_tab.innerHTML = e.target.value
      const index = JSON.parse(localStorage.index)
      const split = status.active_tab.dataset.id.split('_')
      index[status.active_tab.dataset.theme][split[0]][split[1]] = e.target.value
      localStorage.index = JSON.stringify(index)
    }
  }
  async function update_select_theme () {
    select_theme.innerHTML = `<optgroup label='builtin'>${status.themes.builtin.map(theme => `<option>${theme}</option>`)}</optgroup>` +
    `<optgroup label='saved'> ${status.themes.saved.map(theme => `<option>${theme}</option>`)}</optgroup>`
  }
}

function get_theme() {
  return `
  *{
    box-sizing: border-box;
  }
  section{
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 50;
    display: flex;
    align-items: end;
  }
  .btn{
    font-size: 30px;
    cursor: pointer;
  }
  .popup{
    display: none;
    position: relative;
    bottom: 44px;
    margin-left: -42px;
    gap: 10px;
    align-items: end;
  }
  .popup.active{
    display: flex;
  }
  .popup > .box{
    background: #beb2d7;
    border-radius: 5px;
    padding: 10px;
  }
  .popup .list{
    max-height: 60vh;
    overflow-y: scroll;
  }
  .popup .list .item{
    white-space: nowrap;
    cursor: pointer;
  }
  .popup .list .item > .sub{
    display: block;
    margin-left: 10px;
  }
  .popup .list .item > .sub.hide{
    display: none;
  }
  .popup .list .item > main:hover{
    background: #ada1c6;
  }
  .popup .list .item > main > input{
    display: none;
  }
  .popup .list.active .item > main > input{
    display: inline;
  }
  .popup .list .item.dirty > main > .name{
    color: yellow;
  }
  .popup .editor{
    display: none;
    background: #beb2d7;
    position: relative;
    border-radius: 5px;
    padding: 10px;
  }
  .popup .editor.active{
    display: block;
  }
  .popup .editor h3{
    margin-top: 0;
  }
  .popup .editor .tabs textarea{
    display: none;
    min-height: 44vh;
    min-width: 100%;
  }
  .popup .editor .tabs textarea.active{
    display: block;
  }
  .popup .editor .btns{
    display: flex;
  }
  .popup .editor .btns span{
    padding: 0 5px;
    margin: 0 5px;
    cursor: pointer;
  }
  .popup .editor .btns span.active{
    background: #ada1c6;
  }
  .popup .editor .btns span:hover{
    background: #ae9cd4;
  }
  `
}