/******************************************************************************
  THEME_EDITOR COMPONENT
******************************************************************************/
// ----------------------------------------
// MODULE STATE & ID
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
// ----------------------------------------
const sheet = new CSSStyleSheet
sheet.replaceSync(get_theme())
const default_opts = { }
const shopts = { mode: 'closed' }
// ----------------------------------------

module.exports = theme_editor
async function theme_editor (port) {
  port.onmessage = event => on_rx[event.data.type](event.data)
  // ----------------------------------------
  // ID + JSON STATE
  // ----------------------------------------
  const id = `${ID}:${count++}` // assigns their own name
  const status = { tab_id: 0 }
  const state = STATE.ids[id] = { id, status, wait: {}, net: {}, aka: {}, channels: {}} // all state of instance instance
  const on_rx = {
    init
  }
  const paths =  JSON.parse(await(await fetch('./src/node_modules/css/index.json')).text())
  status.themes = {
    builtin: Object.keys(paths),
    saved: Object.keys(JSON.parse(localStorage.index || (localStorage.index = '{}')))
  }
  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div')
  const shadow = el.attachShadow(shopts)
  shadow.adoptedStyleSheets = [sheet]
  shadow.innerHTML = `
  <main>
    <h3>
    </h3>
    <div class="btns">
      <div class="box"></div>
      <span class="plus">+</span>
    </div>
    <div class="tabs">
    </div>
    <select class="theme"></select>
    <select class="type">
      <option>shared</option>
      <option>uniq</option>
    </select>
    <button class="load">
      Load
    </button>
    <button class="inject">
      Inject
    </button>
    <button class="save_file">
      Save file
    </button>
    <button class="save_pref">
      Save pref
    </button>
    <button class="drop">
      Drop
    </button>
    <button class="reset">
      Reset
    </button>
    <button class="export">
      Export
    </button>
    <button class="import">
      Import
    </button>
    <input style="display: none;" class="upload" type='file' />
    <input class="theme" placeholder='Enter theme' />
    <button class="add">
      Add
    </button>
  </main>
  `
  const inject_btn = shadow.querySelector('.inject')
  const load_btn = shadow.querySelector('.load')
  const save_file_btn = shadow.querySelector('.save_file')
  const save_pref_btn = shadow.querySelector('.save_pref')
  const add_btn = shadow.querySelector('.add')
  const drop_btn = shadow.querySelector('.drop')
  const reset_btn = shadow.querySelector('.reset')
  const upload = shadow.querySelector('.upload')
  const import_btn = shadow.querySelector('.import')
  const export_btn = shadow.querySelector('.export')
  const title = shadow.querySelector('h3')
  const tabs = shadow.querySelector('.tabs')
  const btns = shadow.querySelector('.btns > .box')
  const plus = shadow.querySelector('.plus')
  const select_theme = shadow.querySelector('select.theme')
  const select_type = shadow.querySelector('select.type')
  const input = shadow.querySelector('input.theme')

  inject_btn.onclick = inject
  load_btn.onclick = () => load(select_theme.value)
  save_file_btn.onclick = save_file
  save_pref_btn.onclick = save_pref
  add_btn.onclick = () => add(input.value)
  drop_btn.onclick = drop
  export_btn.onclick = export_fn
  import_btn.onclick = () => upload.click()
  upload.onchange = import_fn
  reset_btn.onclick = () => localStorage.clear()
  plus.onclick = () => add_tab('New')
  port.onmessage = event => on_rx[event.data.type](event.data)
  update_select_theme()

  return el

  async function init ({ data }) {
    tabs.innerHTML = ''
    btns.innerHTML = ''
    title.innerHTML = data.id
    status.title = data.type
    status.instance_id = data.id
    init_css(data)
  }
  async function export_fn () {
    const theme = JSON.parse(localStorage[select_theme.value])
    const index = JSON.parse(localStorage.index)[select_theme.value]
    const blob = new Blob([JSON.stringify({theme, index}, null, 2)], { type: "application/json" })
    const url = URL.createObjectURL(blob)
    const a = document.createElement("a")
    a.href = url
    a.download = select_theme.value
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  }
  async function import_fn () {
    const file = upload.files[0]
    const name = file.name.split('.')[0]
    await add(name)
    const reader = new FileReader()
    reader.onload = e => {
      const blob = JSON.parse(e.target.result)
      localStorage[name] = JSON.stringify(blob.theme)
      const index = JSON.parse(localStorage.index)
      index[name] = blob.index
      localStorage.index = JSON.stringify(index)
      load(name)
    }
    reader.readAsText(file)
  }
  async function add (theme) {
    localStorage[theme] = '{}'
    status.themes.saved.push(theme)
    const index = JSON.parse(localStorage.index)
    index[theme] = {}
    localStorage.index = JSON.stringify(index)
    update_select_theme()
  }
  async function drop () {
    localStorage.removeItem(select_theme.value)
    status.themes.saved = status.themes.saved.filter(v => v != select_theme.value)
    update_select_theme()
    select_theme.value = 'default'
    load()
  }
  async function forget_changes () {
    status.active_el.classList.remove('dirty')
    const dirt = JSON.parse(localStorage.dirt)
    delete(dirt[status.title])
    localStorage.dirt = JSON.stringify(dirt)
  }
  async function save_file () {
    // forget_changes()
    const theme = localStorage[select_theme.value] && JSON.parse(localStorage[select_theme.value])
    if(theme){
      const index = JSON.parse(localStorage.index)
      theme[status.title] || (theme[status.title] = [], index[select_theme.value][status.title] = [])
      theme[status.title].push(status.textarea.value)
      index[select_theme.value][status.title].push(status.active_tab.dataset.name)
      localStorage[select_theme.value] = JSON.stringify(theme)
      localStorage.index = JSON.stringify(index)
    }
  }
  async function save_pref () {
    const pref = JSON.parse(localStorage.pref)
    if(select_type.value === "uniq"){
      pref[status.instance_id] || (pref[status.instance_id] = [])
      pref[status.instance_id].push({theme: select_theme.value, id:status.active_tab.dataset.id.split('_')[1], local: status.themes.builtin.includes(select_theme.value) })
    }
    else{
      pref[status.title] || (pref[status.title] = [])
      pref[status.title].push({theme: select_theme.value, id:status.active_tab.dataset.id.split('_')[1], local: status.themes.builtin.includes(select_theme.value) })
    }
    localStorage.pref = JSON.stringify(pref)
  }
  async function unsave () {
    status.active_el.classList.add('dirty')
    let theme = localStorage[select_theme.value] && JSON.parse(localStorage[select_theme.value])
    if(theme){
      theme.css[status.title] = textarea.value
      localStorage[select_theme.value] = JSON.stringify(theme)
      const dirt = JSON.parse(localStorage.dirt)
      dirt[status.title] = select_theme.value
      localStorage.dirt = JSON.stringify(dirt)
    }
    else{
      const name = select_theme.value + '*'
      theme = localStorage[name] && JSON.parse(localStorage[name])
      if(theme){
        theme.css[status.title] = textarea.value
        localStorage[name] = JSON.stringify(theme)
        const dirt = JSON.parse(localStorage.dirt)
        dirt[status.title] = name
        localStorage.dirt = JSON.stringify(dirt)
      }
      else{
        theme = { theme: true, css: {} }
        theme.css[status.title] = textarea.value
        localStorage[name] = JSON.stringify(theme)
        status.themes.saved.push(name)
        const dirt = JSON.parse(localStorage.dirt)
        dirt[status.title] = name
        localStorage.dirt = JSON.stringify(dirt)
        update_select_theme()
        select_theme.value = name
      }
    }
  }
  async function inject () {
    port.postMessage({type: 'send', to_type: select_type.value === 'uniq' ? 'inject' : 'inject_all', to: status.instance_id, data: status.textarea.value})
  }
  async function load (theme) {
    tabs.innerHTML = ''
    btns.innerHTML = ''
    if(status.themes.builtin.includes(theme)){
      const index = paths[theme][status.title].length
      for(let i = 0; i < index; i++){
        const temp = await fetch(`./src/node_modules/css/${theme}/${status.title}/${i}.css`)
        add_tab(`${status.title}_${i}`, await temp.text(), '', theme)
      }
    }
    else{
      const temp = JSON.parse(localStorage[theme])[status.title]
      temp.forEach((file, i) => {
          add_tab(`${status.title}_${i}`, file, '', theme)
      })
    }
    // forget_changes()
  }
  async function init_css ({id, type, uniq, shared, hub}) {
    const pref = JSON.parse(localStorage.pref)
    const pref_shared = pref[type] || shared
    const pref_uniq = pref[id] || uniq
    await Promise.all(pref_shared.map(async v => await add_tab(`${type}_${v.id}`, await get_css(v, type), 'shared', v.theme)))
    await Promise.all(pref_uniq.map(async v => await add_tab(`${type}_${v.id}`, await get_css(v, type), 'uniq', v.theme)))
  }
  async function add_tab (id, css = '', type = 'uniq', theme = 'default') {
    if(id === 'New' && status.themes.builtin.includes(theme)){
      theme += '*'
      add(theme)
    }
    const btn = document.createElement('span')
    const tab_id = 'a' + status.tab_id++
    btn.id = tab_id
    const split = id.split('_')
    const index = paths[theme] || JSON.parse(localStorage.index)[theme]
    btn.innerHTML = index[split[0]] ? index[split[0]][split[1]] : id
    btn.dataset.id = id
    btn.dataset.name = btn.innerHTML
    btn.dataset.theme = theme
    btn.dataset.type = type
    btns.append(btn)
    btn.onclick = () => switch_tab(btn.id)
    btn.ondblclick = rename
    const textarea = document.createElement('textarea')
    textarea.value = css
    textarea.id = tab_id
    tabs.append(textarea)
    switch_tab(tab_id)
  }
  async function switch_tab (tab_id) {
    status.textarea && status.textarea.classList.remove('active')
    status.textarea = tabs.querySelector('#' + tab_id)
    status.textarea.classList.add('active')
    status.active_tab && status.active_tab.classList.remove('active')
    status.active_tab = btns.querySelector('#' + tab_id)
    status.active_tab.classList.add('active')
    select_type.value = status.active_tab.dataset.type
    select_theme.value = status.active_tab.dataset.theme
  }
  async function get_css ({ local = true, theme = 'default', id }, name) {
    let theme_css
    if(local)
      theme_css = await (await fetch(`./src/node_modules/css/${theme}/${name}/${id}.css`)).text()
    else
      theme_css = JSON.parse(localStorage[theme])[name][id]
    return theme_css
  }
  async function rename (e) {
    const btn = e.target
    if(btn.children.length)
      return
    const input = document.createElement('input')
    input.value = btn.innerHTML
    btn.innerHTML = ''
    btn.append(input)
    input.onkeydown = e => {
      if(e.key === 'Enter'){
        btn.innerHTML = input.value
        const index = JSON.parse(localStorage.index)
        const split = btn.dataset.id.split('_')
        index[btn.dataset.theme][split[0]][split[1]] = input.value
        localStorage.index = JSON.stringify(index)
      }
    }
    input.onblur = e => {
      if(e.relatedTarget)
        btn.innerHTML = btn.dataset.name
    }
    input.focus()
  }
  async function update_select_theme () {
    select_theme.innerHTML = `<optgroup label='builtin'>${status.themes.builtin.map(theme => `<option>${theme}</option>`)}</optgroup>` +
    `<optgroup label='saved'> ${status.themes.saved.map(theme => `<option>${theme}</option>`)}</optgroup>`
  }
}

function get_theme () {
  return `
  main{
    background: #beb2d7;
    position: relative;
    border-radius: 5px;
    padding: 10px;
  }
  h3{
    margin-top: 0;
  }
  .tabs textarea{
    display: none;
    min-height: 44vh;
    min-width: 100%;
  }
  .tabs textarea.active{
    display: block;
  }
  .btns{
    display: flex;
  }
  .btns span{
    padding: 0 5px;
    margin: 0 5px;
    cursor: pointer;
  }
  .btns span.active{
    background: #ada1c6;
  }
  .btns span:hover{
    background: #ae9cd4;
  }
  `
}